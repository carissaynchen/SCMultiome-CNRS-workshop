[{"path":[]},{"path":"https://carissaynchen.github.io/SCMultiome-CNRS-workshop-R/articles/advancedphenotyping.html","id":"description","dir":"Articles","previous_headings":"Overview","what":"Description","title":"Advanced Cell Phenotyping","text":"Cellular phenotyping broadly refers procedures aim identify identity /state cells, well relationship cells. section, discus challenges analytical focus associated cellular phenotyping. overall learning goals workshop understand trajectory analysis, common approach phenotype continuous cell states timecourse data. also discuss general analytical strategies associated phenotyping single cells future perspectives.  Preparation pre-reading Trajectory analysis Slingshot Trajectory analysis Monocle3 Monocle3 Documentation Cepo  Learning objectives identify different workflows build trajectory including calculate pseudo-times generate appropriate graphics visualise trajectories expression genes understand different trajectory characterisation approaches including differentially expressed genes across trajectories","code":""},{"path":[]},{"path":"https://carissaynchen.github.io/SCMultiome-CNRS-workshop-R/articles/advancedphenotyping.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Advanced Cell Phenotyping","text":"Many biological processes manifest continuum dynamic changes diverse cellular states. One major goals single cell data analysis identify characterize cell types states induced external stimulation (environmental insults perturbations), spatial context, point along differentiation system cell lies . Collectively, biological, genetic environmental factors contribute towards diversity phenotypes see among cells. define process phenotyping procedure attempts characterize identity /state cells relationship cells distinct procedures relating pre-processing clustering data. One common basic phenotyping procedure cell type identification, highly researched topic single cell data analysis. can explore various characteristics cells investigating cell lies along trajectory, data demonstrates pseudo-temporally ordered state; determining multiple branches trajectory (may associate different cell type lineages); previous true, distinguishing certain gene expression programs associated certain trajectory differential expression analysis gene set enrichment studies; lastly; investigating certain signalling patterns can observed cell types. Collectively, efforts contribute towards phenotyping data obtaining descriptive characterization data hand. Thus, question becomes identify diverse phenotypes? Whilst single cell data enables us interrogate heterogeneity among phenotypes tease different distinct states, cell’s phenotype manifestation collective integrated output set molecules networks span across multiple modalities (transcriptome, genome, epigenome, proteome etc). workshop, begin investigate using single-cell transcriptomes, acknowledging time single modality alone may sufficient accurately pinpoint phenotypes present data. workshop, demonstrate trajectory analysis using mouse scRNA-seq dataset hippocampus Hochgerner et al. (2018)","code":""},{"path":"https://carissaynchen.github.io/SCMultiome-CNRS-workshop-R/articles/advancedphenotyping.html","id":"loading-libraries-and-the-data","dir":"Articles","previous_headings":"","what":"Loading libraries and the data","title":"Advanced Cell Phenotyping","text":"","code":"library(slingshot) library(SingleCellExperiment) library(scater) library(ggplot2) library(ggthemes) library(ggpubr) library(reshape2) library(patchwork) library(scater) library(scran) library(Seurat) library(ggrastr) library(tidyverse) library(ggridges) library(shiny) library(DT) library(Cepo) library(UpSetR) library(BiocParallel)  theme_set(theme_bw()) load(file=\"../data/hippocampus_minimal.rda\") sce <- hippocampus_minimal rm(hippocampus_minimal)  sce <- logNormCounts(sce)"},{"path":"https://carissaynchen.github.io/SCMultiome-CNRS-workshop-R/articles/advancedphenotyping.html","id":"initial-visualisation-of-the-data","dir":"Articles","previous_headings":"","what":"Initial visualisation of the data","title":"Advanced Cell Phenotyping","text":"visualise data using PCA, t-SNE UMAP calculated previous section workshop.  visualisations suggests presence clear trajectory. Starting progenitor cells (neural intermediate progenitor cells (“nIPC”), bifurcation trajectory two major lineages: immature dentate gyrus granule neurons (“immature-GC”) immature pyramidal neurons (“Immature-Pyr”).","code":"p1 <- plotPCA(sce, colour_by = \"cell_cluster\", point_size=0.5) + ggtitle(\"PCA\") p2 <- plotTSNE(sce, colour_by = \"cell_cluster\", point_size=0.5) + ggtitle(\"TSNE\") p3 <- plotUMAP(sce, colour_by = \"cell_cluster\", point_size=0.5) + ggtitle(\"UMAP\")  patchwork::wrap_plots(list(p1 + p2 + p3), guides=\"collect\")"},{"path":"https://carissaynchen.github.io/SCMultiome-CNRS-workshop-R/articles/advancedphenotyping.html","id":"trajectory-inference-how-can-i-infer-the-trajectory-for-my-data","dir":"Articles","previous_headings":"","what":"Trajectory inference: How can I infer the trajectory for my data?","title":"Advanced Cell Phenotyping","text":"section contains two parts. first part focuses four key steps building trajectory second part focuses quality assessment built trajectory.","code":""},{"path":[]},{"path":"https://carissaynchen.github.io/SCMultiome-CNRS-workshop-R/articles/advancedphenotyping.html","id":"step-1-feature-selection","dir":"Articles","previous_headings":"Trajectory inference: How can I infer the trajectory for my data? > Building a trajectory","what":"Step 1: Feature selection","title":"Advanced Cell Phenotyping","text":"One first step building trajectory perform feature selection. Given high dimensional nature high throughput single cell data, oftentimes advantageous select genes provide biologically relevant information remove add noise data. many ways perform feature selection single cell data, reviewed . workshop, demonstrate feature selection using differential stability Cepo choose top 150 cell identity genes cell type.","code":"cepo = Cepo::Cepo(logcounts(sce), sce$cell_cluster, exprsPct = 0.05) cepoGenes = unique(unlist(Cepo::topGenes(cepo, n = 150)))"},{"path":"https://carissaynchen.github.io/SCMultiome-CNRS-workshop-R/articles/advancedphenotyping.html","id":"step-2-dimensionality-reduction","dir":"Articles","previous_headings":"Trajectory inference: How can I infer the trajectory for my data? > Building a trajectory","what":"Step 2: Dimensionality reduction","title":"Advanced Cell Phenotyping","text":"code demonstrate using Cepo selected genes perform PCA.  Similarly, different dimensionality reduction approaches illustrate use t-SNE UMAP achieve purposes.  PCA looks similar previous visualisation using HVGs, can see t-SNE UMAP greater refinement two potential subpopulations within immature pyramidal cells.","code":"set.seed(2024) sce = scater::runPCA(sce, scale = TRUE, subset_row = cepoGenes, name=\"PCA_Cepo\") plotReducedDim(sce, dimred = \"PCA_Cepo\", colour_by = \"cell_cluster\", point_size=0.5) + ggtitle(\"Cepo_PCA\") set.seed(2024) sce = scater::runTSNE(sce, dimred = \"PCA\", name=\"TSNE_Cepo\", BPPARAM= MulticoreParam(workers = 4)) sce = scater::runUMAP(sce, dimred = \"PCA\", name=\"UMAP_Cepo\", min_dist=0.5,  BPPARAM=MulticoreParam(workers = 4))  p2 = plotReducedDim(sce, dimred = \"TSNE_Cepo\", colour_by = \"cell_cluster\", point_size=0.5) + ggtitle(\"Cepo_TSNE\") p3 = plotReducedDim(sce, dimred = \"UMAP_Cepo\", colour_by = \"cell_cluster\", point_size=0.5) + ggtitle(\"Cepo_UMAP\")  patchwork::wrap_plots(list(p2, p3), guides=\"collect\")"},{"path":"https://carissaynchen.github.io/SCMultiome-CNRS-workshop-R/articles/advancedphenotyping.html","id":"step-3-creating-a-lineage-structure-and-pseudo-time-inference","dir":"Articles","previous_headings":"Trajectory inference: How can I infer the trajectory for my data? > Building a trajectory","what":"Step 3: Creating a lineage structure and pseudo-time inference","title":"Advanced Cell Phenotyping","text":"Building trajectory infer construct trajectory steps 3 4 often combined one function many methods. Development trajectory inference methods actively evolving, effectiveness current trajectory inference tools transcriptomics data extensively reviewed benchmarking paper. workshop, run slingshot UMAP reduced dimension space example, details implementation can found . basic input slingshot : expression matrix (SCE object), cell type labels, coordinates reduced dimensions. Details: Slingshot implements two-stage procedure whereby first step infers global lineage structure using multi-spanning tree (MST) infers pseudo-time cells along lineage fitting simultaneous “principal curves” across multiple lineages. known, can also assign starting node/cell type (.e., “nIPC”).","code":"slingshot_umap <- slingshot(sce,                             clusterLabels = sce$cell_cluster,                             reducedDim = \"UMAP_Cepo\",                             start.clus = \"nIPC\")"},{"path":[]},{"path":"https://carissaynchen.github.io/SCMultiome-CNRS-workshop-R/articles/advancedphenotyping.html","id":"visualisation-with-base-r","dir":"Articles","previous_headings":"Trajectory inference: How can I infer the trajectory for my data? > Building a trajectory > Step 4: Visualisation of the trajectory","what":"Visualisation with base R","title":"Advanced Cell Phenotyping","text":"Let us visualise slingshot results using base R","code":"rd <- reducedDim(slingshot_umap, \"UMAP_Cepo\") plotcol <- tableau_color_pal(\"Classic 10\")(5)[as.factor(slingshot_umap$cell_cluster)]  # set the aspect ratio for base R plot as 1 par(pty = \"s\") plot(rd, col = plotcol,      pch = 16, asp = 1, xlab = \"UMAP1\", ylab = \"UMAP2\") lines(SlingshotDataSet(slingshot_umap), lwd=2, col='black')"},{"path":"https://carissaynchen.github.io/SCMultiome-CNRS-workshop-R/articles/advancedphenotyping.html","id":"visualisation-the-same-results-using-ggplot2-","dir":"Articles","previous_headings":"Trajectory inference: How can I infer the trajectory for my data? > Building a trajectory > Step 4: Visualisation of the trajectory","what":"Visualisation the same results using ggplot2.","title":"Advanced Cell Phenotyping","text":"can see total two lineages identified slingshot, trajectory nIPCs Neuroblast bifurcates Neuroblast give rise two terminal cell types, Immature Granule Cells Immature Pyramidal Cells","code":"df_toPlot_umap <- data.frame(UMAP1 = rd[, 1],                         UMAP2 = rd[, 2],                         ClusterName = slingshot_umap$cell_cluster) pseudotime_umap <- slingshot::slingPseudotime(slingshot_umap) df_toPlot_umap <- cbind(df_toPlot_umap, pseudotime_umap)  curves <- slingCurves(slingshot_umap, as.df = TRUE)  ggplot() +   geom_point(data = df_toPlot_umap, aes(x = UMAP1, y = UMAP2, color = ClusterName), size=0.5) +   geom_path(data = curves,             aes(x = UMAP1, y = UMAP2, group = Lineage)) +   scale_color_tableau(palette = \"Classic 10\") +   theme(aspect.ratio = 1)"},{"path":"https://carissaynchen.github.io/SCMultiome-CNRS-workshop-R/articles/advancedphenotyping.html","id":"visualisation-of-the-inferred-pseudotime-lineages","dir":"Articles","previous_headings":"Trajectory inference: How can I infer the trajectory for my data?","what":"Visualisation of the inferred pseudotime lineages","title":"Advanced Cell Phenotyping","text":"interesting visualisation see pseudotimes inferred individual branches. using slingshot::slingPseudotime function, can access inferred pseudotimes individual cells lineages identified.","code":"## visualising the pseuotime df_toPlot_umap2 <- reshape2::melt(df_toPlot_umap, id = c(\"UMAP1\", \"UMAP2\", \"ClusterName\")) colnames(df_toPlot_umap2) <- c(\"UMAP1\", \"UMAP2\", \"ClusterName\", \"Lineages\", \"Pseudotime\")  ggplot() +   geom_point(data = df_toPlot_umap2, aes(x = UMAP1, y = UMAP2, color = Pseudotime)) +   geom_path(data = curves,             aes(x = UMAP1, y = UMAP2, group = Lineage)) +   scale_color_viridis_c() +   theme(aspect.ratio = 1) +   facet_wrap(~Lineages)"},{"path":"https://carissaynchen.github.io/SCMultiome-CNRS-workshop-R/articles/advancedphenotyping.html","id":"visualisation-of-the-density-of-cells-along-the-pseudotime","dir":"Articles","previous_headings":"Trajectory inference: How can I infer the trajectory for my data?","what":"Visualisation of the density of cells along the pseudotime","title":"Advanced Cell Phenotyping","text":"Using frequency cells identified along pseudotime, can also visualise density cells cell type along two lineages using geom_density_ridges2 function.  users wanting explore alternative methods build trajectory, please refer dynverse framework, provides uniform interface run 50 trajectory inference methods. Discussion: orderings make sense given cluster labels? ? specifying starting cluster (start.clus) impact trajectory results? additional exercise, performing dimensionality reduction different set/number selected features impact trajectory results? try different dimensionality reduction technique?","code":"ggplot() +   geom_density_ridges2(data = df_toPlot_umap2,                        aes(x = Pseudotime, y = ClusterName, fill = ClusterName),                        alpha = 0.5) +   scale_fill_tableau(palette = \"Classic 10\") +   theme(aspect.ratio = 1, legend.position = \"bottom\") +   facet_wrap(~Lineages)"},{"path":"https://carissaynchen.github.io/SCMultiome-CNRS-workshop-R/articles/advancedphenotyping.html","id":"is-my-trajectory-appropriate-or-sensible","dir":"Articles","previous_headings":"","what":"Is my trajectory appropriate or sensible?","title":"Advanced Cell Phenotyping","text":"section, look critical thinking questions researcher ask trajectory.","code":""},{"path":"https://carissaynchen.github.io/SCMultiome-CNRS-workshop-R/articles/advancedphenotyping.html","id":"how-well-do-the-pseudotime-orderings-correlate-from-different-trajectory-methods","dir":"Articles","previous_headings":"Is my trajectory appropriate or sensible?","what":"How well do the pseudotime orderings correlate from different trajectory methods?","title":"Advanced Cell Phenotyping","text":"example illustrate concordance results running two different trajectory inference methods, use monocle3 construct trajectory UMAP space compare results slingshot. black lines show structure graph. circles numbers denote special points within graph. leaf, denoted light gray circles, corresponds different outcome (.e. cell fate) trajectory. Black circles indicate branch nodes, cells can travel one several outcomes. can control whether shown plot label_leaves label_branch_points arguments plot_cells. Note numbers within circles provided reference purposes .  Interpretation: Similar approach using slingshot, visualisation monocle3 approach shows two distinct lineages, replicating bifurcation point Neuroblast.","code":"library(monocle3) # Construct cell data set object for monocle3 rowData(sce) <- DataFrame(rowData(sce), gene_short_name = rownames(sce)) cds <- as(sce, \"cell_data_set\") colData(cds)[, 1] <- NULL cds <- cluster_cells(cds, cluster_method = \"leiden\") # plot_cells(cds, color_cells_by = \"partition\")  cds <- learn_graph(cds, use_partition = FALSE, close_loop=FALSE, verbose=TRUE) # set use_partition to FALSE so only a single graph is learnt  plot_cells(cds, reduction_method = \"UMAP\",            color_cells_by = \"cell_cluster\", label_groups_by_cluster=FALSE,            group_label_size = 4, graph_label_size = 4) +   scale_color_tableau(palette = \"Classic 10\") +   theme(aspect.ratio = 1)"},{"path":"https://carissaynchen.github.io/SCMultiome-CNRS-workshop-R/articles/advancedphenotyping.html","id":"are-the-trajectory-methods-robust-to-the-choice-of-root-cells","dir":"Articles","previous_headings":"Is my trajectory appropriate or sensible? > How well do the pseudotime orderings correlate from different trajectory methods?","what":"Are the trajectory methods robust to the choice of “root cells”?","title":"Advanced Cell Phenotyping","text":"can now calculate pseudotimes. Note important set cell type origin (.e., cell type denoting earliest temporal point differentiation calculating pseudotimes. monocle3, need provide root_cells, requires us specify set cells root cell type. creating customised function get_earliest_principal_node , can arbitrarily assign set cell cell type origin root_cells. ’s often desirable specify root trajectory programmatically, rather manually picking . function first grouping cells according trajectory graph node nearest . , calculates fraction cells node come earliest time point. picks node heavily occupied early cells returns root.  can evaluate concordance pseudotimes inferred across two trajectory inference methods, slingshot monocle3 calculating simple pearson’s correlation. satisfied agreement?  Discussion: Can use order_cells monocle3 know root cell type ?","code":"get_earliest_principal_node <- function(cds, coldata_name, start.clust){   cell_ids <- which(colData(cds)[, coldata_name] == start.clust)   closest_vertex <- cds@principal_graph_aux[[\"UMAP\"]]$pr_graph_cell_proj_closest_vertex   closest_vertex <- as.matrix(closest_vertex[colnames(cds), ])   root_pr_nodes <- igraph::V(principal_graph(cds)[[\"UMAP\"]])$name[as.numeric(names(which.max(table(closest_vertex[cell_ids,]))))]   root_pr_nodes }  # Set the root cells root_cells <- get_earliest_principal_node(cds, coldata_name = \"cell_cluster\",                                           start.clust = \"nIPC\") # Order the cells to calculate pseudotime cds <- order_cells(cds, root_pr_nodes = root_cells)  plot_cells(cds,            color_cells_by = \"pseudotime\",            label_cell_groups = FALSE,            # label_leaves = FALSE,            # label_branch_points = FALSE,            graph_label_size = 4, group_label_size = 4) +   theme(aspect.ratio = 1) monocle3_pseudotime <- cds@principal_graph_aux[[\"UMAP\"]]$pseudotime par(pty = \"s\") plot(monocle3_pseudotime, pseudotime_umap[, 1], xlab = \"Monocle 3\", ylab = \"Slingshot (Lineage 1)\") cor(monocle3_pseudotime, pseudotime_umap[, 1], use = \"complete.obs\") #> [1] 0.9776447"},{"path":"https://carissaynchen.github.io/SCMultiome-CNRS-workshop-R/articles/advancedphenotyping.html","id":"how-can-i-characterise-the-trajectory-of-the-data","dir":"Articles","previous_headings":"","what":"How can I characterise the trajectory of the data?","title":"Advanced Cell Phenotyping","text":"far, built trajectory mouse hippocampus data using transcriptomes single cells. process, determined presence two distinct lineages trajectory line underlying biological system, investigated impact using different dimensionality reduction techniques different methods trajectory inference. can now phenotype trajectories investigating changes specific gene expressions programs across lineages. ask following questions: Within lineage, genes differentially expressed across pseudotime? genes exhibit different patterns gene expression across pseudotime lineages? Can group genes terms gene expression patterns across pseudotime? specific pathways gene sets enriched gene groups? gene-pair correlations change across lineages?","code":""},{"path":"https://carissaynchen.github.io/SCMultiome-CNRS-workshop-R/articles/advancedphenotyping.html","id":"within-a-lineage-which-genes-are-differentially-expressed-across-a-pseudotime","dir":"Articles","previous_headings":"How can I characterise the trajectory of the data?","what":"Within a lineage, which genes are differentially expressed across a pseudotime?","title":"Advanced Cell Phenotyping","text":"Background: suitable statistical model determining gene expression related pseudotime generalise additive model. generalised additive model (GAM) statistics generalised linear model linear response variable linearly dependent unknown smooth functions certain predictor variables. GAMs can thought bridge simple linear models advanced machine-learning techniques, allowing researchers model non-linear data complex systems. GAM, inference smooth functions frequently main focus. GAM model typically written \\[ y = \\beta_0 + f(t) + \\epsilon; \\epsilon \\sim N(0,\\sigma^2)\\] \\(t\\) represents pseudotime. approach tradeSeq Berge et al., 2020 implement negative bionomial-GAM (NA-GAM) model detect genes differentially expressed along one multiple lineages trajectory. NB-GAMS model can fitted using functions tradeSeq. choice knot number important model parameters. parameter specifies complex data expression patterns , higher number knots allowing intricate expression patterns. optimal choice knots can derived using evaluateK function. data contains many conditions, use conditions option fit individual smoothers condition. Computation: interest time, suggest performing analysis using component computationally intensive, ‘fitGAM’ process, seen , take ten minutes complete. alternative, recommend completing rest tutorial pre-run output. Test association Next, using fitted gene expressions, can assess significant changes gene expression (.e., differential expression) function pseudotime within lineage using associationTest function. Importantly, setting lineages = TRUE specify differential expression analysis performed lineage separately, well performing test across lineages simultaneously. , focus perform association test Cepo selected genes. use UpSetR package visualise number intersecting exclusive genes.   Interpretation: Based upset graphics, see large overlap DE genes three lineages (around 93%). pseudotime graph, can check whether expression identified DE gene indeed change pseudotime within lineage. example, select RUNX1T1, gene found differentially expressed two lineages.","code":"- the set of differentially stable genes (450 genes) derived earlier in this workshop; and - set `knots = 6` when fitting the NB-GAM. library(tradeSeq) slingshot_umap <- slingshot_umap[!duplicated(rownames(slingshot_umap)),]  if (!file.exists(\"../data/slingshot_umap.rda\")) {   slingshot_umap <- fitGAM(slingshot_umap,                            genes = cepoGenes,                            nknots = 6,                            verbose = TRUE,                            parallel = FALSE,                            sce = TRUE,                            family = \"nb\",                            gcv = FALSE)   save(slingshot_umap, file = \"../data/slingshot_umap.rda\") } else {   load(file=\"../data/slingshot_umap.rda\") }  table(rowData(slingshot_umap)$tradeSeq$converged) #>  #> TRUE  #>  567 assoRes <- associationTest(slingshot_umap[cepoGenes, ], global = TRUE, lineages = TRUE) assoRes <- assoRes[order(assoRes$waldStat, decreasing = TRUE),] datatable(assoRes) %>%   formatSignif(which(sapply(assoRes, is, 'numeric')), digits = 3) ## extracting candidate from each lineage lineage1Genes <-  rownames(assoRes)[which(p.adjust(assoRes$pvalue_1, \"fdr\") <= 0.05)] lineage2Genes <-  rownames(assoRes)[which(p.adjust(assoRes$pvalue_2, \"fdr\") <= 0.05)] allGenes <-  rownames(assoRes)[which(p.adjust(assoRes$pvalue, \"fdr\") <= 0.05)]  DEgenes = list(   lineage1 = lineage1Genes,   lineage2 = lineage2Genes ) sapply(DEgenes, length) #> lineage1 lineage2  #>      282      287 UpSetR::upset(UpSetR::fromList(DEgenes)) length(setdiff(lineage1Genes, lineage2Genes)) #> [1] 142 length(setdiff(lineage2Genes, lineage1Genes)) #> [1] 147 length(intersect(lineage1Genes, lineage2Genes)) #> [1] 140 plotSmoothers(slingshot_umap, counts(slingshot_umap), gene = c(\"RUNX1T1\"))"},{"path":"https://carissaynchen.github.io/SCMultiome-CNRS-workshop-R/articles/advancedphenotyping.html","id":"which-genes-exhibit-different-patterns-of-gene-expression-across-the-pseudotime-between-lineages","dir":"Articles","previous_headings":"How can I characterise the trajectory of the data?","what":"Which genes exhibit different patterns of gene expression across the pseudotime between lineages?","title":"Advanced Cell Phenotyping","text":"Whilst associationTest looks genes show differential expression across pseudotime within lineage, can also look genes demonstrate different differential expression patterns across lineages patternTest function. accomplished testing whether expression pattern gene varies lineages. previously, focus running pattern test Cepo-selected genes.  Interpretation: 454 567 genes demonstrate differential gene expression patterns lineages. critical, like omics data study, double-check results using visualisation. question, visualise change expression important gene, SYT4.","code":"patternRes <- patternTest(slingshot_umap[cepoGenes,]) patternRes <- patternRes[order(patternRes$waldStat, decreasing = TRUE),] datatable(patternRes) %>%   formatSignif(which(sapply(patternRes, is, 'numeric')), digits = 3) ## determine the number of candidate genes patternGenes <-  rownames(patternRes)[which(p.adjust(patternRes$pvalue, \"fdr\") <= 0.05)] length(patternGenes) #> [1] 454  ## Assessing our results through visualization plotSmoothers(slingshot_umap, counts(slingshot_umap), gene = c(\"SYT4\"))"},{"path":"https://carissaynchen.github.io/SCMultiome-CNRS-workshop-R/articles/advancedphenotyping.html","id":"can-we-group-the-genes-in-terms-of-their-gene-expression-patterns-across-the-pseudotime","dir":"Articles","previous_headings":"How can I characterise the trajectory of the data?","what":"Can we group the genes in terms of their gene expression patterns across the pseudotime?","title":"Advanced Cell Phenotyping","text":"Hypothesis testing (‘patternTest’) generates value describe degree gene’s expression function pseudotime distinct across lineages; however, capture diversity pseudotime patterns among genes. end, can cluster genes according expression pattern along pseudotime lineage using clusterExpressionPattern function tradeSeq package. resulting output clustering label denotes gene groups based like gene expression profiles. Computation: main arguments function Note clustering uses clusterExperiment package (Risso et al. 2018), hence user may select clustering algorithm ’s built package (check output clusterExperiment::listBuiltInFunctions() command line see available methods). clusterExpressionPatterns take minutes run case, can load pre-run results instead. clustering results generated running clusterExpressionPatterns function shows total 52 clustering groups 98 genes assigned cluster may demonstrate unique gene expression patterns. also visualise normalised expression patterns genes three clusters.  Discussion: Can describe various expression patterns? Note two layers differences: genes show (1) differential expression across pseudotime within lineage (2) differential expression patterns significantly different lineages. setting greater number nPoints (e.g., 40, 60, 80) change clustering results?","code":"1) the slingshot output,  2) `nPoints` which denotes the number of points along each lineage to cluster the genes, and  3) the `genes` to use in the clustering. More details of the implementation can be found in [this vignette](https://statomics.github.io/tradeSeq/articles/tradeSeq.html). library(clusterExperiment) nPointsClus <- 20  if (!file.exists(\"../data/clusPat.rda\")) {   clusPat <- tradeSeq::clusterExpressionPatterns(slingshot_umap, nPoints = nPointsClus,                                        genes = rownames(patternRes))   save(clusPat, file=\"../data/clusPat.rda\") } else {   load(file=\"../data/clusPat.rda\") }  clusterLabels <- clusterExperiment::primaryCluster(clusPat$rsec) table(clusterLabels) #> clusterLabels #> -1  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  #> 89 70 33 28 28 25 23 17 31 14 14 13 13 11 10  9  9  8  8  8  8  8  7  7  7  7  #> 26 27 28 29 30 31 32 33 34 35 36  #>  6  6  6  6  6  6  6  5  5  5  5  ggCluster <- list() for (xx in 1:4) {   cId <- which(clusterLabels == c(1,2,3,4)[[xx]])   p <- ggplot(data = data.frame(x = 1:nPointsClus,                                 y = rep(range(clusPat$yhatScaled[cId, ]),                                         nPointsClus / 2)),               aes(x = x, y = y)) +     geom_point(alpha = 0) +     labs(title = paste0(\"Cluster\", c(1,2,3,4)[[xx]]),  x = \"Pseudotime\", y = \"Normalized expression\") +     theme_classic() +     theme(plot.title = element_text(hjust = 0.5))   for (ii in 1:length(cId)) {     geneId <- rownames(clusPat$yhatScaled)[cId[ii]]     p <- p +       geom_line(data = data.frame(x = rep(1:nPointsClus, 2),                                   y = clusPat$yhatScaled[geneId, ],                                   lineage = rep(1:2, each = nPointsClus)),                 aes(col = as.character(lineage), group = lineage), lwd = 1.5)   }   ggCluster[[xx]] <- p + guides(color = \"none\") +     scale_color_manual(values = c(\"orange\", \"darkseagreen3\"),                        breaks = c(\"1\", \"2\")) }  patchwork::wrap_plots(ggCluster, ncol = 4, nrow = 1)"},{"path":"https://carissaynchen.github.io/SCMultiome-CNRS-workshop-R/articles/advancedphenotyping.html","id":"what-is-the-functional-annotation-for-the-various-gene-sets","dir":"Articles","previous_headings":"How can I characterise the trajectory of the data?","what":"What is the functional annotation for the various gene sets?","title":"Advanced Cell Phenotyping","text":"establish functional annotation various clusters genes obtained, similar identifying whether specific pathways gene sets enriched clusters genes. , perform gene set -representation (GO) analysis illustrate analysis identify gene ontology gene sets -represented cluster 1 (70 genes). results shown table. clusterProfiler::dotplot function can used visualise results top significant pathways dot plot size circle represents number genes identified pathway interest color function denotes level significance.  Discussion: top enriched pathways gene set -representation analysis? pathways line expect?","code":"names(clusterLabels) <- rownames(clusPat$yhatScaled) names(clusterLabels) <- rowData(sce)$gene_name[match(names(clusterLabels), rownames(sce))]  library(clusterProfiler) library(org.Mm.eg.db) eg <- bitr(names(clusterLabels)[clusterLabels == 1],            fromType = \"SYMBOL\",            toType = \"ENTREZID\",            OrgDb = \"org.Mm.eg.db\")   geneList <- bitr(rowData(sce)$gene_name,                  fromType = \"SYMBOL\",                  toType = \"ENTREZID\",                  OrgDb = \"org.Mm.eg.db\")  ego_res <- enrichGO(gene = eg$ENTREZID,                     universe = geneList$ENTREZID,                     OrgDb = org.Mm.eg.db,                     ont = \"BP\",                     pAdjustMethod = \"BH\",                     minGSSize = 50,                     maxGSSize = 200,                     pvalueCutoff = 1,                     qvalueCutoff = 1,                     readable = TRUE)  ## generate results head(as.data.frame(ego_res)) #>                    ID                                               Description #> GO:0000070 GO:0000070                      mitotic sister chromatid segregation #> GO:1902850 GO:1902850 microtubule cytoskeleton organization involved in mitosis #> GO:0007051 GO:0007051                                      spindle organization #> GO:0051983 GO:0051983                      regulation of chromosome segregation #> GO:0051310 GO:0051310                            metaphase chromosome alignment #> GO:0007052 GO:0007052                              mitotic spindle organization #>            GeneRatio   BgRatio       pvalue     p.adjust       qvalue #> GO:0000070     26/65 169/20311 8.629563e-38 2.934051e-35 1.916671e-35 #> GO:1902850     22/65 152/20311 3.246372e-31 5.518832e-29 3.605181e-29 #> GO:0007051     22/65 182/20311 2.113668e-29 2.395490e-27 1.564856e-27 #> GO:0051983     20/65 127/20311 3.923134e-29 3.334664e-27 2.178372e-27 #> GO:0051310     17/65  86/20311 1.338809e-26 9.103901e-25 5.947131e-25 #> GO:0007052     18/65 119/20311 6.867068e-26 3.891338e-24 2.542020e-24 #>                                                                                                                                                           geneID #> GO:0000070 Aurkb/Birc5/Ccnb1/Cdca8/Cdk1/Cenpe/Cenpk/Cit/Fbxo5/Incenp/Kif11/Kif22/Kif23/Kif2c/Kifc1/Mad2l1/Ncapg/Nuf2/Nusap1/Plk1/Prc1/Spag5/Spc24/Spc25/Tpx2/Ttk #> GO:1902850                    Aurka/Aurkb/Birc5/Ccnb1/Cdca8/Cdk1/Cenpe/Cenph/Gpsm2/Incenp/Kif11/Kif23/Kifc1/Mad2l1/Nuf2/Nusap1/Plk1/Prc1/Sapcd2/Spc25/Tacc3/Tpx2 #> GO:0007051                       Aspm/Aurka/Aurkb/Birc5/Ccnb1/Ccnb2/Cdca8/Cenpe/Cenph/Fbxo5/Gpsm2/Incenp/Kif11/Kif23/Kifc1/Nuf2/Plk1/Prc1/Spag5/Spc25/Tacc3/Tpx2 #> GO:0051983                                    Aurkb/Birc5/Ccnb1/Cdca2/Cdca8/Cdk1/Cenpe/Cit/Fbxo5/Incenp/Kif2c/Mad2l1/Mki67/Ncapg/Nuf2/Plk1/Spc24/Spc25/Tacc3/Ttk #> GO:0051310                                                 Aurkb/Birc5/Ccnb1/Cdca8/Cenpe/Cenpf/Cenpq/Ect2/Fam83d/Incenp/Kif22/Kif2c/Kifc1/Nuf2/Spag5/Spc24/Spc25 #> GO:0007052                                              Aurka/Aurkb/Birc5/Ccnb1/Cdca8/Cenpe/Cenph/Gpsm2/Incenp/Kif11/Kif23/Kifc1/Nuf2/Plk1/Prc1/Spc25/Tacc3/Tpx2 #>            Count #> GO:0000070    26 #> GO:1902850    22 #> GO:0007051    22 #> GO:0051983    20 #> GO:0051310    17 #> GO:0007052    18 clusterProfiler::dotplot(ego_res)"},{"path":"https://carissaynchen.github.io/SCMultiome-CNRS-workshop-R/articles/advancedphenotyping.html","id":"optional-which-gene-pair-correlations-change-across-lineages","dir":"Articles","previous_headings":"","what":"[Optional] Which gene-pair correlations change across lineages?","title":"Advanced Cell Phenotyping","text":"previous four questions, focus identify candidate gene interest. aim identify candidate “gene-pair”. achieve using algorithm called scHOT Ghzanfar et al., 2020, can test change gene expression pair genes across pseudotime. R package, two statistical higher order testing can perform, controlled higherOrderFunction argument scHOT. can test differential variability differential correlation pairs genes across pseudotime. 1) variability: higherOrderFunction = matrixStats::weightedVar 2) correlation: higherOrderFunction = matrixStats::weightedSpearman Computation: reduce computation time, select top 10 genes identified associationTest. identify gene pairs differential correlated across pseudotime lineage, visualise results top 5 significant gene pairs demonstrate differential correlation across pseudotime.","code":"library(scHOT)  first_branch_cells <- !is.na(slingshot_umap$slingPseudotime_1) assoRes_lingeage1_top10 <- rownames(assoRes[order(assoRes$waldStat_1, decreasing = TRUE),])[1:10] gene_to_test <- t(combn(assoRes_lingeage1_top10, 2)) if(!file.exists(\"../data/scHOT_obj.rda\")) {   scHOT_obj <- scHOT_buildFromMatrix(     mat = logcounts(slingshot_umap)[,first_branch_cells],     cellData = list(pseudotime = slingshot_umap$slingPseudotime_1[first_branch_cells]),     positionType = \"trajectory\",     positionColData = \"pseudotime\")   scHOT_obj      scHOT_obj <- scHOT(scHOT_obj,                      testingScaffold = gene_to_test,                      nrow.out = 100, # The number of weightings to include for testing, a smaller value is faster for computation                      higherOrderFunction = weightedSpearman,                      higherOrderFunctionType = \"weighted\",                      numberPermutations = 50)      scHOT_obj@scHOT_output <- scHOT_obj@scHOT_output[order(scHOT_obj@scHOT_output$FDREstimated),]   save(scHOT_obj, file =\"../data/scHOT_obj.rda\") } else {   load(file=\"../data/scHOT_obj.rda\") }  plotHigherOrderSequence(scHOT_obj, rownames(scHOT_obj@scHOT_output)[1:5])"},{"path":"https://carissaynchen.github.io/SCMultiome-CNRS-workshop-R/articles/advancedphenotyping.html","id":"reference-and-other-useful-resources","dir":"Articles","previous_headings":"","what":"Reference and other useful resources","title":"Advanced Cell Phenotyping","text":"dynverse, collection R packages aimed supporting trajectory inference: https://dynverse.org","code":""},{"path":[]},{"path":"https://carissaynchen.github.io/SCMultiome-CNRS-workshop-R/articles/basics_of_single-cell_annotation.html","id":"description","dir":"Articles","previous_headings":"Overview","what":"Description","title":"Basics of Single-cell Annotation","text":"Single-cell annotation key step scRNA-seq analysis reveal heterogeneity present data downstream analyses characterise specific cell type differences. section workshop, explore unsupervised supervised techniques cell type identification, leveraging tools clustering algorithms, marker gene annotation, machine learning classifiers. learning goals section understand different ways cell type annotation can performed scenarios preferable use either approach.  Preparation assumed knowledge Use dimensionality reduction single-cell genomics scClassify  Learning objectives Apply different dimensionality reduction techniques customise visualisation perform unsupervised supervised procedures annotate cell types scRNA-seq data Think critically disadvantages advantages approach","code":""},{"path":"https://carissaynchen.github.io/SCMultiome-CNRS-workshop-R/articles/basics_of_single-cell_annotation.html","id":"schedule","dir":"Articles","previous_headings":"Overview","what":"Schedule","title":"Basics of Single-cell Annotation","text":"Structure section:","code":""},{"path":"https://carissaynchen.github.io/SCMultiome-CNRS-workshop-R/articles/basics_of_single-cell_annotation.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Basics of Single-cell Annotation","text":"now preprocessed single cell data. next step analyse data cell type identification, identification marker genes et cetera. focus simple steps downstream analysis single cell RNA-sequencing (scRNA-seq) data shown . cell types present dataset? cell clusters? gene interest, can visualise gene expression distribution? cell type composition data? Two common approaches used - unsupervised clustering manual annotation using marker genes, annotation supervised classification. Unsupervised clustering method groups cells clusters based gene expression profiles without prior knowledge cell types. goal identify groupings cells similar transcriptomic profiles correspond single cell type. clustering, resulting groupings annotated using known marker genes highly expressed specific cell types, serving defining signature cell type. Alternatively, differential gene analysis can performed clusters determine selection top genes related specific cell types annotate cluster. appropriate reference single-cell dataset, can opt use supervised classification algorithm classify cells. Typically, classification model trained labeled dataset, learns relationships cell types gene expression profiles. , trained model applied new, unlabeled dataset predict cell type based prior gene expression information. tutorial explore example typical unsupervised annotation method using Seurat, demonstrate usage supervised classification using scClassify.","code":""},{"path":"https://carissaynchen.github.io/SCMultiome-CNRS-workshop-R/articles/basics_of_single-cell_annotation.html","id":"loading-libraries-and-the-data","dir":"Articles","previous_headings":"","what":"Loading libraries and the data","title":"Basics of Single-cell Annotation","text":"simplify data, take two time points simplify data, take continuous cell types helpful next part workshop.","code":"library(SingleCellExperiment) library(ggthemes) library(ggpubr) library(ggplot2) library(reshape2) library(patchwork) library(scater) library(scran) library(Seurat) library(ggrastr) library(tidyverse) library(mclust) library(presto) library(DT) theme_set(theme_bw()) load(file=\"../data/hippocampus_processed.rda\") sce <- hippocampus_processed rm(hippocampus_processed) sce <- sce[, sce$age %in% c(\"P0\", \"P5\")] keep <- c(\"Immature-GC\", \"Immature-Pyr\", \"Neuroblast\", \"nIPC\") sce <- sce[, sce$cell_cluster %in% keep] convert_to_seurat <- function(sce, meta = TRUE, ...) {   drops <- rownames(sce)   if (meta)      meta.data <- colData(sce)   else meta.data <- NULL   counts <- counts(sce)[drops, ,drop = FALSE]   seur <- Seurat::CreateSeuratObject(counts = counts, meta.data = as.data.frame(meta.data))   return(seur) }  seu <- convert_to_seurat(sce)"},{"path":[]},{"path":"https://carissaynchen.github.io/SCMultiome-CNRS-workshop-R/articles/basics_of_single-cell_annotation.html","id":"data-normalisation-and-scaling","dir":"Articles","previous_headings":"Data visualisation using dimensionality reduction","what":"Data normalisation and scaling","title":"Basics of Single-cell Annotation","text":"RNA-seq data, often genes expressed extreme magnitudes, variance often skews distribution data. many statistical methods often assume approximately normal distribution, log normalisation data crucial step stabilise variance data make interpretable. log normalisation data, next step find highly variable genes (HVGs). feature space large, often perform step detect crucial genes contribute cell-cell variation scRNA-seq. help narrow feature space include biologically informative genes, also help decrease computational time downstream analyses.","code":"seu <- NormalizeData(seu, normalization.method = \"LogNormalize\", scale.factor = 10000) seu <- FindVariableFeatures(seu, selection.method = \"vst\") seu <- ScaleData(seu, verbose = FALSE, do.scale = TRUE, do.center = FALSE)"},{"path":"https://carissaynchen.github.io/SCMultiome-CNRS-workshop-R/articles/basics_of_single-cell_annotation.html","id":"performing-dimensionality-reduction","dir":"Articles","previous_headings":"Data visualisation using dimensionality reduction","what":"Performing dimensionality reduction","title":"Basics of Single-cell Annotation","text":"Principal Component Analysis (PCA) statistical technique transform high dimensionality data low dimensionality data whilst retaining variability data Principal Components (PCs). typically performed prior running dimensionality reduction technique algorithms t-SNE UMAP computationally intensive, reduces computational load memory required whilst optimizing performance. visualise data using three dimensionality reduction approaches color individual data points (denoting single cells) provided cell type labels. Without much knowledge biological system, can guess whether discrete continuous cell types? can infer lineages?  Exercises: happens visualisations change TSNE perplexity parameter? happens visualisations change UMAP min.dist parameter?","code":"seu <- RunPCA(seu, verbose = FALSE) seu <- RunTSNE(seu, reduction = \"pca\", perplexity=200) seu <- RunUMAP(seu, reduction = \"pca\", dims = 1:15, min.dist = 0.5) p1 <- DimPlot(seu, reduction = \"pca\", group.by = \"age\") + ggtitle(\"PCA\") p2 <- DimPlot(seu, reduction = \"tsne\", group.by = \"age\") + ggtitle(\"TSNE\") p3 <- DimPlot(seu, reduction = \"umap\", group.by = \"age\") + ggtitle(\"UMAP\")  p4 <- DimPlot(seu, reduction = \"pca\", group.by = \"cell_cluster\") + ggtitle(\"PCA\") p5 <- DimPlot(seu, reduction = \"tsne\", group.by = \"cell_cluster\") + ggtitle(\"TSNE\") p6 <- DimPlot(seu, reduction = \"umap\", group.by = \"cell_cluster\") + ggtitle(\"UMAP\")  patchwork::wrap_plots(list(p1, p2, p3, p4, p5, p6), nrow=2, guides=\"collect\") tmp <- RunTSNE(seu, reduction = \"pca\", reduction.name = \"tsne\", perplexity=100) DimPlot(tmp, reduction = \"tsne\", group.by = \"age\") tmp <- RunUMAP(seu, reduction = \"pca\", reduction.name = \"umap\", dims = 1:15, min.dist = 0.7) DimPlot(tmp, reduction = \"umap\", group.by = \"age\")"},{"path":"https://carissaynchen.github.io/SCMultiome-CNRS-workshop-R/articles/basics_of_single-cell_annotation.html","id":"unsupervised-clustering-and-annotation-of-scrna-seq-data","dir":"Articles","previous_headings":"","what":"Unsupervised clustering and annotation of scRNA-seq data","title":"Basics of Single-cell Annotation","text":"may always suitable reference dataset single-cell RNA-seq experiment, therefore need start first identifying many distinct groups populations can find data. One common method achieve statistical technique called clustering. clustering method group similar samples (cells) together partition samples different comparing feature information (gene expression).","code":""},{"path":"https://carissaynchen.github.io/SCMultiome-CNRS-workshop-R/articles/basics_of_single-cell_annotation.html","id":"how-many-clusters-do-i-have-in-my-data","dir":"Articles","previous_headings":"Unsupervised clustering and annotation of scRNA-seq data","what":"How many clusters do I have in my data?","title":"Basics of Single-cell Annotation","text":"cluster cells using Seurat implementation louvain clustering. separately visualise cells time, see cells overlap regardless timepoint belong , therefore cluster data together.  Since know number cell types expected, purpose tutorial, set resolution parameter gives us similar number clusters equal unique cell types. Discussion: resolution parameter ? choose right resolution?","code":"p1 <- DimPlot(seu, reduction = \"pca\", group.by = \"age\", split.by = \"age\") + ggtitle(\"PCA\") p2 <- DimPlot(seu, reduction = \"tsne\", group.by = \"age\", split.by = \"age\") + ggtitle(\"TSNE\") p3 <- DimPlot(seu, reduction = \"umap\", group.by = \"age\", split.by = \"age\") + ggtitle(\"UMAP\")  patchwork::wrap_plots(list(p1, p2, p3), nrow=1, guides=\"collect\") seu <- FindNeighbors(seu, dims = 1:10) seu <- FindClusters(seu, resolution = 0.1) #> Modularity Optimizer version 1.3.0 by Ludo Waltman and Nees Jan van Eck #>  #> Number of nodes: 5412 #> Number of edges: 178258 #>  #> Running Louvain algorithm... #> Maximum modularity in 10 random starts: 0.9560 #> Number of communities: 4 #> Elapsed time: 0 seconds"},{"path":"https://carissaynchen.github.io/SCMultiome-CNRS-workshop-R/articles/basics_of_single-cell_annotation.html","id":"for-a-gene-of-interest-how-can-i-visualise-the-gene-expression-distribution","dir":"Articles","previous_headings":"Unsupervised clustering and annotation of scRNA-seq data","what":"For a gene of interest, how can I visualise the gene expression distribution?","title":"Basics of Single-cell Annotation","text":", generated unique clusters, can annotate data using known marker genes. Discussion: think unsupervised clustering performed?  known marker genes cell types expect data: nIPCs: Neurog2, Tfap2c Neuroblast: Eomes, Igfbpl1 Immature Granule Cell (GC): Prox1, Fxyd7 Immature Pyramidal Cell (Pyr): Ncam1 Feel free visualise different marker genes visualise distribution gene expression across cells. Discussion: parameter change FeaturePlot view data age? think marker genes informative identify specific cell types?  Alternatively, can use cluster assignments perform differential expression analysis find differential genes clusters define cell types. Lets use see can find markers immature pyramidal cells. step takes minutes, can load pre-calculated results. Discussion: top markers tell identity cluster? [Optional] can evaluate clustering performance using cell type labels provided publications.  Discussion: additional visualisations can use determine annotations marker gene expression?","code":"p1 <- DimPlot(seu, reduction = \"umap\", group.by = \"RNA_snn_res.0.1\") + ggtitle(\"UMAP\") p2 <- DimPlot(seu, reduction = \"umap\", group.by = \"cell_cluster\") + ggtitle(\"UMAP\")  p1 + p2 markers = c(\"TFAP2C\", \"NEUROG2\", \"EOMES\", \"IGFBPL1\", \"FXYD1\", \"PROX1\", \"NCAM1\")  FeaturePlot(seu, features = markers, reduction = \"umap\", pt.size = 0.2) if(!file.exists(\"../data/cluster1.markers_RNA_snn_res.0.1.rda\")) {   cluster1.markers <- FindMarkers(seu, ident.1 = 1, test.use = \"wilcox\", min.pct=0.01)   save(cluster1.markers, file=\"data/cluster1.markers_RNA_snn_res.0.1.rda\")    } else {   load(file=\"../data/cluster1.markers_RNA_snn_res.0.1.rda\")   cluster1.markers <- cluster1.markers_RNA_snn_res.0.1 }  pos_only <- cluster1.markers %>%   dplyr::filter(avg_log2FC > 1) # fill in the code to visualise the new marker genes obtained from the DE analysis. seu <- FindClusters(seu, resolution = 0.5) # compare with a different resolution #> Modularity Optimizer version 1.3.0 by Ludo Waltman and Nees Jan van Eck #>  #> Number of nodes: 5412 #> Number of edges: 178258 #>  #> Running Louvain algorithm... #> Maximum modularity in 10 random starts: 0.8966 #> Number of communities: 11 #> Elapsed time: 0 seconds # ARI ari = c(mclust::adjustedRandIndex(seu$cell_cluster, seu$RNA_snn_res.0.1),         mclust::adjustedRandIndex(seu$cell_cluster, seu$RNA_snn_res.0.5))  # NMI nmi = c(igraph::compare(as.numeric(factor(seu$cell_cluster)),                         seu$RNA_snn_res.0.1, method = \"nmi\"),         igraph::compare(as.numeric(factor(seu$cell_cluster)),                         seu$RNA_snn_res.0.5, method = \"nmi\"))  plot_data = data.frame(   res = rep(c(\"res_0.1\", \"res_0.5\"), 2),   value = c(ari, nmi),   eval = rep(c(\"ARI\", \"NMI\"), each = 2) )  ggplot(plot_data, aes(x = res, y = value, fill = res)) +   geom_bar(stat=\"identity\") +   facet_grid(col = vars(eval)) +   labs(x = \"Clustering resolution\",        y = \"Evalution score\") +   theme(legend.position = \"none\")"},{"path":"https://carissaynchen.github.io/SCMultiome-CNRS-workshop-R/articles/basics_of_single-cell_annotation.html","id":"what-is-the-cell-type-composition-of-my-data","dir":"Articles","previous_headings":"Unsupervised clustering and annotation of scRNA-seq data","what":"What is the cell type composition of my data?","title":"Basics of Single-cell Annotation","text":"identified cell types, often interest visualise cell type proportions across conditions (ie. age). Discussion: useful visualise absolute counts proportions?","code":"plot_data <- data.frame(table(seu$cell_cluster, seu$age))  p1 <- ggplot(plot_data,        aes(x = Var2,            y = Freq,            fill = Var1)) +   geom_bar(stat = \"identity\") +   labs(x = \"Age\",        y = \"Frequency\",        title = \"Composition of cell types\") +   coord_flip()  p2 <- ggplot(plot_data,        aes(x = Var2,            y = Freq,            fill = Var1)) +   geom_bar(position=\"fill\", stat=\"identity\") +   labs(x = \"Age\",        y = \"Frequency\",        title = \"Composition of cell types\") +   coord_flip()   p1 / p2"},{"path":"https://carissaynchen.github.io/SCMultiome-CNRS-workshop-R/articles/basics_of_single-cell_annotation.html","id":"perform-cell-classification-with-scclassify","dir":"Articles","previous_headings":"","what":"Perform cell classification with scClassify","title":"Basics of Single-cell Annotation","text":"take advantage large collection well-annotated scRNA-seq datasets, scClassify package implements set methods perform accurate cell type classification based ensemble learning sample size calculation. details can viewed original paper code shows example utilise subset data reference data classify remaining data. first perform non-ensemble scClassify using 70% data reference dataset. use WKNN KNN algorithm, DE (differential expression genes) gene selection method. per previous study, found Pearson correlation optimal similarity metric comparing single cell RNA-seq data (Kim et al., 2018, thus choose pearson similarity calculation method. can visualise cell type hierarchy tree using plotCellTypeTree():  Next, perform predict_scClassify() trained model trainRes = train_scClassify predict cell types query data matrix test. , check prediction results original labels.  can quickly quantify number cells assigned unique label.","code":"set.seed(2023) # subsample 70% of the data as training dataset, and rest as test idx <- sample(ncol(seu), round(ncol(seu)*0.7))  train <- GetAssayData(seu, layer=\"data\")[, idx] test <- GetAssayData(seu, layer=\"data\")[, -idx]  cellTypes_train <- seu$cell_cluster[idx] cellTypes_test <- seu$cell_cluster[-idx]  table(cellTypes_train) #> cellTypes_train #>  Immature-GC Immature-Pyr   Neuroblast         nIPC  #>         1133         1938          601          116 train_scClassify <- scClassify::train_scClassify(exprsMat_train = train,                                             cellTypes_train = cellTypes_train,                                            algorithm = \"WKNN\",                                            selectFeatures = c(\"limma\"),                                            similarity = c(\"pearson\"),                                            returnList = FALSE,                                            verbose = TRUE) #> after filtering not expressed genes  #> [1] 9990 3788 #> [1] \"Feature Selection...\" #> [1] \"Number of genes selected to construct HOPACH tree 165\" #> [1] \"Constructing tree ...\" #> [1] \"Training....\" #> [1] \"=== selecting features by: limma ====\"  train_scClassify #> Class: scClassifyTrainModel  #> Model name: training  #> Feature selection methods: limma  #> Number of cells in the training data: 3788  #> Number of cell types in the training data: 4 scClassify::plotCellTypeTree(train_scClassify@cellTypeTree, group_level = 3) pred_res <- scClassify::predict_scClassify(exprsMat_test = test,                                cellTypes_test = cellTypes_test,                                trainRes = train_scClassify,                                algorithm = \"WKNN\",                                features = c(\"limma\"),                                similarity = c(\"pearson\"),                                prob_threshold = 0.7,                                verbose = TRUE) #> Ensemble learning is disabled...  #> Using parameters:  #> similarity  algorithm   features  #>  \"pearson\"     \"WKNN\"    \"limma\"  #> [1] \"Using dynamic correlation cutoff...\" #> [1] \"Using dynamic correlation cutoff...\" #> [1] \"Using dynamic correlation cutoff...\" #> classify_res #>                correct   correctly unassigned           intermediate  #>             0.93103448             0.00000000             0.01046798  #> incorrectly unassigned         error assigned          misclassified  #>             0.02709360             0.00000000             0.03140394  #> weights for each base method:  #> NULL  scClassify_res <- pred_res$pearson_WKNN_limma$predRes df_scClassify <- data.frame(Embeddings(seu, reduction=\"umap\")[-idx, 1:2],                            label = scClassify_res,                            method = \"scClassify\") df_GT <- data.frame(Embeddings(seu, reduction=\"umap\")[-idx, 1:2],                            label = seu$cell_cluster[-idx],                            method = \"Ground Truth\")  plotdf <- rbind(df_scClassify, df_GT)  ggplot(plotdf, aes(x = umap_1, y = umap_2, colour = label)) +   geom_point(size = 0.2) +   labs(title = \"UMAP plot\") +   facet_grid(~method) +   theme(legend.position = \"bottom\") table(scClassify_res, cellTypes_test) #>                           cellTypes_test #> scClassify_res             Immature-GC Immature-Pyr Neuroblast nIPC #>   Immature-GC                      476            3         34    0 #>   Immature-GC_Immature-Pyr           4            0          3    0 #>   Immature-Pyr                       3          813          6    0 #>   Neuroblast                         2            0        169    0 #>   Neuroblast_nIPC                    0            0         12    1 #>   nIPC                               0            0          0   54 #>   unassigned                        10            3         31    0"},{"path":"https://carissaynchen.github.io/SCMultiome-CNRS-workshop-R/articles/basics_of_single-cell_annotation.html","id":"save-the-processed-data","dir":"Articles","previous_headings":"","what":"Save the processed data","title":"Basics of Single-cell Annotation","text":"","code":"reducedDim(sce, \"PCA\") <- Embeddings(seu, reduction=\"pca\") reducedDim(sce, \"TSNE\") <- Embeddings(seu, reduction=\"tsne\") reducedDim(sce, \"UMAP\") <- Embeddings(seu, reduction=\"umap\")  # save(sce, file=\"data/hippocampus_minimal.rda\")"},{"path":"https://carissaynchen.github.io/SCMultiome-CNRS-workshop-R/articles/basics_of_single-cell_annotation.html","id":"references-and-other-useful-resources","dir":"Articles","previous_headings":"","what":"References and other useful resources","title":"Basics of Single-cell Annotation","text":"Seurat clustering tutorial","code":""},{"path":[]},{"path":"https://carissaynchen.github.io/SCMultiome-CNRS-workshop-R/articles/citefuse.html","id":"description","dir":"Articles","previous_headings":"Overview","what":"Description","title":"Analysis of CITE-seq data with CiteFuse","text":"scRNA-seq allowed us dissect complex cell populations transcriptomic level, however lacks additional phenotypic information quantification cell-surface proteins often useful distinguish closely related cell states (eg. immunology). CITE-seq uses oligonucleotide-labeled antibodies integrate cellular protein transcriptomic measurements single-cell readout. first section introduce single-cell multi-modal analysis, learn pre-process integratively explore CITE-seq data using CiteFuse package.","code":""},{"path":"https://carissaynchen.github.io/SCMultiome-CNRS-workshop-R/articles/citefuse.html","id":"preparation-and-assumed-knowledge","dir":"Articles","previous_headings":"Overview","what":"Preparation and assumed knowledge","title":"Analysis of CITE-seq data with CiteFuse","text":"CITE-seq technology Analysing CITE-seq CiteFuse CiteFuse vignette","code":""},{"path":"https://carissaynchen.github.io/SCMultiome-CNRS-workshop-R/articles/citefuse.html","id":"learning-objectives","dir":"Articles","previous_headings":"Overview","what":"Learning objectives","title":"Analysis of CITE-seq data with CiteFuse","text":"understand output CITE-seq data pre-process CITE-seq data perform exploratory analysis learn jointly visualise modalities integrate RNA-ADT information construct interaction networks","code":""},{"path":"https://carissaynchen.github.io/SCMultiome-CNRS-workshop-R/articles/citefuse.html","id":"schedule","dir":"Articles","previous_headings":"Overview","what":"Schedule","title":"Analysis of CITE-seq data with CiteFuse","text":"Structure section:","code":""},{"path":"https://carissaynchen.github.io/SCMultiome-CNRS-workshop-R/articles/citefuse.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Analysis of CITE-seq data with CiteFuse","text":"CITE-seq protocol involves conjugating antibodies oligonucleotides, antibody specific cell surface protein marker. antibodies bind specific protein marker, mRNA lysed cell. molecular species captured scRNA-sequencing. process called ‘cell hashing’, cells stained sample-specific oligonucleotide-labelled antibodies (‘hashing antibodies’), thus allowing samples multiplexed sequenced single experiment later traced back origin. Thus, allowing high-throughput high-dimensional multi-omic single-cell analysis. CiteFuse computational framework implements suite methods tools CITE-seq data pre-processing integrative analytics. includes doublet detection, network-based modality integration, cell type clustering, differential RNA protein expression analysis, ADT evaluation, ligand-receptor interaction analysis, interactive web-based visualisation analyses. workshop, demonstrate usage CiteFuse subset data CITE-seq data human PBMCs example Mimitou et al., 2019.","code":""},{"path":"https://carissaynchen.github.io/SCMultiome-CNRS-workshop-R/articles/citefuse.html","id":"loading-libraries-and-the-data","dir":"Articles","previous_headings":"","what":"Loading libraries and the data","title":"Analysis of CITE-seq data with CiteFuse","text":", start list three matrices unique molecular identifier (UMI), antibody derived tags (ADT) hashtag oligonucleotide (HTO) count, common cell names. 500 cells subsetted dataset. characteristically CITE-seq data, matrices matched, meaning given cell know expression level RNA transcripts (genome-wide) corresponding cell surface protein expression. preprocessing function utilise three matrices common cell names create SingleCellExperiment object, stores RNA data assay ADT HTO data within altExp slot.","code":"library(CiteFuse) library(scater) library(SingleCellExperiment) library(DT) library(patchwork) library(mclust) data(\"CITEseq_example\", package = \"CiteFuse\") names(CITEseq_example) #> [1] \"RNA\" \"ADT\" \"HTO\" lapply(CITEseq_example, dim) #> $RNA #> [1] 19521   500 #>  #> $ADT #> [1]  49 500 #>  #> $HTO #> [1]   4 500 sce_citeseq <- preprocessing(CITEseq_example) sce_citeseq #> class: SingleCellExperiment  #> dim: 19521 500  #> metadata(0): #> assays(1): counts #> rownames(19521): hg19_AL627309.1 hg19_AL669831.5 ... hg19_MT-ND6 #>   hg19_MT-CYB #> rowData names(0): #> colnames(500): AAGCCGCGTTGTCTTT GATCGCGGTTATCGGT ... TTGGCAACACTAGTAC #>   GCTGCGAGTTGTGGCC #> colData names(0): #> reducedDimNames(0): #> mainExpName: NULL #> altExpNames(2): ADT HTO"},{"path":"https://carissaynchen.github.io/SCMultiome-CNRS-workshop-R/articles/citefuse.html","id":"performing-doublet-detection","dir":"Articles","previous_headings":"","what":"Performing doublet detection","title":"Analysis of CITE-seq data with CiteFuse","text":"important step single cell data analysis removal doublets. Doublets form result co-encapsulation cells within droplet, leading hybrid transcriptome two cells. CiteFuse, implement step-wise doublet detection approach remove doublets. first identify cross-sample doublets, cells different samples captured ‘single’ cell. , identify within-sample doublets, two cells sample captured together droplet.","code":""},{"path":"https://carissaynchen.github.io/SCMultiome-CNRS-workshop-R/articles/citefuse.html","id":"normalisation-and-initial-visualisation-of-hto-counts","dir":"Articles","previous_headings":"Performing doublet detection","what":"Normalisation and initial visualisation of HTO counts","title":"Analysis of CITE-seq data with CiteFuse","text":"function normaliseExprs used scale alternative expression. , used perform log-transformation HTO count, setting transform = \"log\". can perform dimension reduction HTO count using runTSNE runUMAP, use visualiseDim function visualise reduced dimension plot. CITE-seq dataset contain data four samples pooled sequencing. samples multiplexed cell hashing Stoeckius et al., 2018. four clusters observed reduced dimension plots equate four different samples.","code":"sce_citeseq <- normaliseExprs(sce = sce_citeseq,                                altExp_name = \"HTO\",                                transform = \"log\") sce_citeseq <- scater::runTSNE(sce_citeseq,                                 altexp = \"HTO\",                                 name = \"TSNE_HTO\",                                 pca = TRUE)  sce_citeseq <- scater::runUMAP(sce_citeseq,                                 altexp = \"HTO\",                                 name = \"UMAP_HTO\")  p1 <- visualiseDim(sce_citeseq,              dimNames = \"TSNE_HTO\") + labs(title = \"tSNE (HTO)\") p2 <- visualiseDim(sce_citeseq,              dimNames = \"UMAP_HTO\") + labs(title = \"UMAP (HTO)\")  p1 + p2"},{"path":"https://carissaynchen.github.io/SCMultiome-CNRS-workshop-R/articles/citefuse.html","id":"doublet-identification-step-1-cross-sample-doublet-detection","dir":"Articles","previous_headings":"Performing doublet detection","what":"Doublet identification step 1: cross-sample doublet detection","title":"Analysis of CITE-seq data with CiteFuse","text":"predict cross-sample doublets, fit two-component Gaussian mixture model log-transformed HTO count. intersection point defined mixture model used categorize cell terms whether HTO signal either high low. sample stained hashtag distinctive sample, cells theory associated one HTO signal show negligible signal others. Therefore, cells found single high-signal HTO considered singlets whilst two high-signal HTOs considered doublets multiplets. Cells without high-signal HTOs considered empty droplets. run crossSampleDoublets results cross sample doublets saved colData slot doubletClassify_between_label doubletClassify_between_class. can highlight cross-sample doublets tSNE plot HTO count. visualise label class doublets side--side?","code":"sce_citeseq <- crossSampleDoublets(sce_citeseq) #> number of iterations= 20  #> number of iterations= 24  #> number of iterations= 46  #> number of iterations= 50 table(sce_citeseq$doubletClassify_between_label) #>  #>                 1                 2                 3                 4  #>               115               121                92               129  #> doublet/multiplet  #>                43 table(sce_citeseq$doubletClassify_between_class) #>  #> doublet/multiplet           Singlet  #>                43               457 visualiseDim(sce_citeseq,               dimNames = \"TSNE_HTO\",               colour_by = \"doubletClassify_between_label\") # insert code to visualise \"doubletClassify_between_class\""},{"path":"https://carissaynchen.github.io/SCMultiome-CNRS-workshop-R/articles/citefuse.html","id":"doublet-identification-step-2-within-sample-doublet-detection","dir":"Articles","previous_headings":"Performing doublet detection","what":"Doublet identification step 2: within-sample doublet detection","title":"Analysis of CITE-seq data with CiteFuse","text":"Data filtered cross-sample doublets next subject within-sample doublet identification using density-based spatial clustering noise detection algorithm (DBSCAN) matrix comprising two types features—total unique molecular identifier (UMI) count log-transformed HTO count. two parameters used DBSCAN study eps=190 minPts=50. smallest cluster (.e. outliers) DBSCAN clustering assigned within-sample doublets. identify within-sample doublets via withinSampleDoublets function. results cross sample doublets saved colData doubletClassify_within_label doubletClassify_within_class. Questions: eps minPts parameters? happens vary parameters? , can visualise within-sample doublets tSNE plot. visualise within label within class doublets side--side?  Furthermore, plotHTO function allows us plot pairwise scatter HTO count. cells show co-expression orthogonal HTOs (red) considered doublets. comparison cross-sample doublets?  Finally, can filter doublet cells (within batches) downstream analysis.","code":"sce_citeseq <- withinSampleDoublets(sce_citeseq, minPts = 10) table(sce_citeseq$doubletClassify_within_label) #>  #>  Doublets(Within)_1  Doublets(Within)_2  Doublets(Within)_3  Doublets(Within)_4  #>                   3                   7                   4                   6  #> NotDoublets(Within)  #>                 480 table(sce_citeseq$doubletClassify_within_class) #>  #> Doublet Singlet  #>      20     480 visualiseDim(sce_citeseq,               dimNames = \"TSNE_HTO\",               colour_by = \"doubletClassify_within_label\") # insert code to visualise \"doubletClassify_within_class\" plotHTO(sce_citeseq, 1:4) sce_citeseq <- sce_citeseq[, sce_citeseq$doubletClassify_within_class == \"Singlet\" & sce_citeseq$doubletClassify_between_class == \"Singlet\"] sce_citeseq #> class: SingleCellExperiment  #> dim: 19521 437  #> metadata(3): doubletClassify_between_threshold #>   doubletClassify_between_resultsMat doubletClassify_within_resultsMat #> assays(1): counts #> rownames(19521): hg19_AL627309.1 hg19_AL669831.5 ... hg19_MT-ND6 #>   hg19_MT-CYB #> rowData names(0): #> colnames(437): GATCGCGGTTATCGGT GGCTGGTAGAGGTTAT ... TTGGCAACACTAGTAC #>   GCTGCGAGTTGTGGCC #> colData names(5): doubletClassify_between_label #>   doubletClassify_between_class nUMI doubletClassify_within_label #>   doubletClassify_within_class #> reducedDimNames(2): TSNE_HTO UMAP_HTO #> mainExpName: NULL #> altExpNames(2): ADT HTO"},{"path":"https://carissaynchen.github.io/SCMultiome-CNRS-workshop-R/articles/citefuse.html","id":"integration-of-rna-and-adt-using-snf","dir":"Articles","previous_headings":"","what":"Integration of RNA and ADT using SNF","title":"Analysis of CITE-seq data with CiteFuse","text":"next step analysis integrate RNA ADT matrix. use popular integration algorithm called similarity network fusion (SNF) integrate multi-omic data. now proceed fused matrix, stored SNF_W metadata slot sce_citeseq object. can calculate t-SNE generate integrated embedding using SNF network.","code":"sce_citeseq <- scater::logNormCounts(sce_citeseq) sce_citeseq <- normaliseExprs(sce_citeseq, altExp_name = \"ADT\", transform = \"log\") sce_citeseq <- CiteFuse(sce_citeseq) #> Calculating affinity matrix  #> Performing SNF sce_citeseq <- reducedDimSNF(sce_citeseq,                              method = \"tSNE\",                               dimNames = \"tSNE_joint\")"},{"path":[]},{"path":"https://carissaynchen.github.io/SCMultiome-CNRS-workshop-R/articles/citefuse.html","id":"clustering-using-louvain-clustering","dir":"Articles","previous_headings":"How many clusters are in my data?","what":"Clustering using Louvain clustering","title":"Analysis of CITE-seq data with CiteFuse","text":"well spectral clustering, CiteFuse can implement Louvain clustering users wish use another clustering method. use igraph package, community detection algorithms available package can selected changing method parameter. outcome clustering can easily visualised reduced dimensions plot highlighting points cluster label.  Alternatively, clustering can easily visualised using KNN graph labelled cluster number.","code":"set.seed(2024) SNF_W_louvain <- igraphClustering(sce_citeseq, method = \"louvain\") table(SNF_W_louvain) #> SNF_W_louvain #>   1   2   3   4   5   6   7  #>  88 137  65  32  51  28  36  sce_citeseq$SNF_W_louvain <- as.factor(SNF_W_louvain) visualiseDim(sce_citeseq, dimNames = \"tSNE_joint\", colour_by = \"SNF_W_louvain\") +   labs(title = \"tSNE (SNF louvain clustering)\") set.seed(2024) visualiseKNN(sce_citeseq, colour_by = \"SNF_W_louvain\")"},{"path":"https://carissaynchen.github.io/SCMultiome-CNRS-workshop-R/articles/citefuse.html","id":"optional-clustering-using-spectral-clustering","dir":"Articles","previous_headings":"How many clusters are in my data?","what":"[Optional] Clustering using Spectral clustering","title":"Analysis of CITE-seq data with CiteFuse","text":"CiteFuse implements two different clustering algorithms fused matrix, spectral clustering Louvain clustering. First, perform spectral clustering sufficient numbers K use eigen values determine optimal number clusters. optimal number clusters ?  Using optimal cluster number defined previous step, can now use spectralClustering function cluster single cells specifying number clusters K. function takes cell--cell similarity matrix input. already created fused similarity matrix CiteFuse. Since CiteFuse function creates stores similarity matries ADT RNA expression, well fused matrix, can use two compare clustering outcomes data modality.","code":"SNF_W_clust <- spectralClustering(metadata(sce_citeseq)[[\"SNF_W\"]], K = 20) #> Computing Spectral Clustering plot(SNF_W_clust$eigen_values) which.max(abs(diff(SNF_W_clust$eigen_values))) #> [1] 5 SNF_W_clust <- spectralClustering(metadata(sce_citeseq)[[\"SNF_W\"]], K = 5) #> Computing Spectral Clustering sce_citeseq$SNF_W_clust <- as.factor(SNF_W_clust$labels)  SNF_W1_clust <- spectralClustering(metadata(sce_citeseq)[[\"ADT_W\"]], K = 5) #> Computing Spectral Clustering sce_citeseq$ADT_clust <- as.factor(SNF_W1_clust$labels)  SNF_W2_clust <- spectralClustering(metadata(sce_citeseq)[[\"RNA_W\"]], K = 5) #> Computing Spectral Clustering sce_citeseq$RNA_clust <- as.factor(SNF_W2_clust$labels)"},{"path":"https://carissaynchen.github.io/SCMultiome-CNRS-workshop-R/articles/citefuse.html","id":"exploratory-analysis-of-feature-expression-across-modalities","dir":"Articles","previous_headings":"","what":"Exploratory analysis of feature expression across modalities","title":"Analysis of CITE-seq data with CiteFuse","text":"CiteFuse wide range visualisation tools facilitate exploratory analysis CITE-seq data. visualiseExprs function easy--use function generate boxplots, violin plots, jitter plots, density plots, pairwise scatter/density plots genes proteins expressed data. plots can grouped using cluster labels stored sce_citeseq object. expression genes proteins can visualised changing colour_by parameter assess clusters. example, highlight plot RNA ADT expression level CD8.  Alternative visualisation 1: can plot boxplot expression subset genes per cluster detected louvain clustering algorithm.  Alternative visualisation 2: can plot violin plot expression subset genes per cluster detected louvain clustering algorithm.  Alternative visualisation 3: can plot jitter expression subset genes per cluster detected louvain clustering algorithm.  Alternative visualisation 4: can plot density plot expression subset genes per cluster detected louvain clustering algorithm.  Questions: collection visualisations, notice markers differentially expressed clusters? plot , ADT? Alternative visualisation 5: can also create pairwise scatter plot visualise distribution cells expressing certain markers.  Questions: quadrants correspond ? many cells co-express markers?","code":"g1 <- visualiseDim(sce_citeseq, dimNames = \"tSNE_joint\",                     colour_by = \"hg19_CD8A\",                    data_from = \"assay\",                    assay_name = \"logcounts\") +   labs(title = \"tSNE: hg19_CD8A (RNA expression)\")  g2 <- visualiseDim(sce_citeseq,dimNames = \"tSNE_joint\",                     colour_by = \"CD8\",                    data_from = \"altExp\",                    altExp_assay_name = \"logcounts\") +   labs(title = \"tSNE: CD8 (ADT expression)\")  g1 + g2 visualiseExprs(sce_citeseq,                 plot = \"boxplot\",                 altExp_name = \"RNA\",                group_by = \"SNF_W_louvain\",                feature_subset = c(\"hg19_CD2\", \"hg19_CD4\", \"hg19_CD8A\", \"hg19_CD19\")) visualiseExprs(sce_citeseq,                 plot = \"violin\",                altExp_name = \"RNA\",                group_by = \"SNF_W_louvain\",                feature_subset = c(\"hg19_CD2\", \"hg19_CD4\", \"hg19_CD8A\", \"hg19_CD19\")) visualiseExprs(sce_citeseq,                 plot = \"jitter\",                 altExp_name = \"RNA\",                group_by = \"SNF_W_louvain\",                feature_subset = c(\"hg19_CD2\", \"hg19_CD4\", \"hg19_CD8A\", \"hg19_CD19\")) visualiseExprs(sce_citeseq,                 plot = \"density\",                 altExp_name = \"RNA\",                group_by = \"SNF_W_louvain\",                feature_subset = c(\"hg19_CD2\", \"hg19_CD4\", \"hg19_CD8A\", \"hg19_CD19\")) visualiseExprs(sce_citeseq, altExp_name = \"ADT\",                 plot = \"pairwise\",                 feature_subset = c(\"CD4\", \"CD8\")) #> number of iterations= 19  #> number of iterations= 26"},{"path":[]},{"path":"https://carissaynchen.github.io/SCMultiome-CNRS-workshop-R/articles/citefuse.html","id":"perform-de-analysis-with-wilcoxon-rank-sum-test","dir":"Articles","previous_headings":"What genes are differentially expressed between my clusters?","what":"Perform DE Analysis with Wilcoxon Rank Sum test","title":"Analysis of CITE-seq data with CiteFuse","text":"CiteFuse can also calculates differentially expressed (DE) genes DEgenes function. cluster grouping use must specified group parameter. altExp_name specified, RNA expression used default expression matrix. Results form DE analysis stored sce_citeseq DE_res_RNA_filter DE_res_ADT_filter RNA ADT expression, respectively.","code":""},{"path":"https://carissaynchen.github.io/SCMultiome-CNRS-workshop-R/articles/citefuse.html","id":"for-rna-modality","dir":"Articles","previous_headings":"What genes are differentially expressed between my clusters? > Perform DE Analysis with Wilcoxon Rank Sum test","what":"For RNA modality","title":"Analysis of CITE-seq data with CiteFuse","text":"","code":"# DE will be performed for RNA if altExp_name = \"none\"  sce_citeseq <- DEgenes(sce_citeseq,                        altExp_name = \"none\",                         group = sce_citeseq$SNF_W_louvain,                        return_all = TRUE,                        exprs_pct = 0.5)  sce_citeseq <- selectDEgenes(sce_citeseq,                              altExp_name = \"none\")  datatable(format(do.call(rbind, metadata(sce_citeseq)[[\"DE_res_RNA_filter\"]]),                   digits = 2))"},{"path":"https://carissaynchen.github.io/SCMultiome-CNRS-workshop-R/articles/citefuse.html","id":"for-adt-modality","dir":"Articles","previous_headings":"What genes are differentially expressed between my clusters? > Perform DE Analysis with Wilcoxon Rank Sum test","what":"For ADT modality","title":"Analysis of CITE-seq data with CiteFuse","text":"","code":"sce_citeseq <- DEgenes(sce_citeseq,                        altExp_name = \"ADT\",                         group = sce_citeseq$SNF_W_louvain,                        return_all = TRUE,                        exprs_pct = 0.5)  sce_citeseq <- selectDEgenes(sce_citeseq,                              altExp_name = \"ADT\")  datatable(format(do.call(rbind, metadata(sce_citeseq)[[\"DE_res_ADT_filter\"]]),                   digits = 2))"},{"path":"https://carissaynchen.github.io/SCMultiome-CNRS-workshop-R/articles/citefuse.html","id":"visualising-de-results","dir":"Articles","previous_headings":"What genes are differentially expressed between my clusters?","what":"Visualising DE Results","title":"Analysis of CITE-seq data with CiteFuse","text":"running DE analysis, obtain p-value relevant statistics rank differentially expressed genes cluster. visualise selection top DE genes, can use `DEcomparisonPlot. lollipop plot shows -log10 transformed adjusted p-values specified genes RNA ADT cluster. requires list features RNA ADT interested , well output DE analysis.  Interpretation: louvain-generated groups, compare -log10 transformed p-values RNA genes (right) ADT markers (left). larger value, significant p-value. , can see cluster 7, significant differential expression MHCII CD19. suggests cluster 7 B cells, possibly B cell subtype.","code":"rna_list <- c(\"hg19_CD4\", \"hg19_CD8A\", \"hg19_HLA-DRB1\", \"hg19_ITGAX\", \"hg19_NCAM1\", \"hg19_CD27\", \"hg19_CD19\")  adt_list <- c(\"CD4\", \"CD8\", \"MHCII (HLA-DR)\", \"CD11c\", \"CD56\", \"CD27\", \"CD19\")  rna_DEgenes_all <- metadata(sce_citeseq)[[\"DE_res_RNA\"]] adt_DEgenes_all <- metadata(sce_citeseq)[[\"DE_res_ADT\"]]  feature_list <- list(RNA = rna_list, ADT = adt_list) de_list <- list(RNA = rna_DEgenes_all, ADT = adt_DEgenes_all)  DEcomparisonPlot(de_list = de_list,                  feature_list = feature_list)"},{"path":[]},{"path":"https://carissaynchen.github.io/SCMultiome-CNRS-workshop-R/articles/citefuse.html","id":"is-there-a-relationship-between-important-molecular-factors-in-rna-and-adt","dir":"Articles","previous_headings":"How do I analyse the RNA and ADT modalities together?","what":"Is there a relationship between important molecular factors in RNA and ADT?","title":"Analysis of CITE-seq data with CiteFuse","text":"can generate network diagram using geneADTnetwork function examine association differentially expressed genes protein markers. specify unique DE genes across clusters RNA ADT modalities calculate correlation genes using cells. nodes denote proteins RNA whilst edges denote positive negative correlation expression. Questions: results change use different correlation method? vary cor_threshold parameter? examine network specific cluster?  Interpretation: roughly 4 groupings interaction network, particularly interest, CD27 CD11b positively correlated RPS RPL ribosomal genes. expected, activated immune cells require increased ribosome biogenesis support immune response.","code":"RNA_feature_subset <- unique(as.character(unlist(lapply(rna_DEgenes_all, \"[[\", \"name\")))) ADT_feature_subset <- unique(as.character(unlist(lapply(adt_DEgenes_all, \"[[\", \"name\"))))  set.seed(2024) netw <- geneADTnetwork(sce_citeseq,                RNA_exprs_value = \"logcounts\",                altExp_name = \"ADT\",                altExp_exprs_value = \"logcounts\",                cell_subset = NULL,                cor_threshold = 0.5,                RNA_feature_subset = RNA_feature_subset,                ADT_feature_subset = ADT_feature_subset,                cor_method = \"pearson\",                network_layout = igraph::layout_with_fr)"},{"path":"https://carissaynchen.github.io/SCMultiome-CNRS-workshop-R/articles/citefuse.html","id":"what-are-the-ligand-receptor-interactions-in-my-data","dir":"Articles","previous_headings":"How do I analyse the RNA and ADT modalities together?","what":"What are the ligand-receptor interactions in my data?","title":"Analysis of CITE-seq data with CiteFuse","text":"Ligand-receptor interactions means cells communicate . Ligands (eg. hormones, neurotransmitters, growth factors etc.) bind specific receptors surface target cells, initiating intracellular signalling cascades alter cell behaviour. take advantage ADT expression, CiteFuse implements ligandReceptorTest find ligand-receptor interactions sender receiver cells. Importantly, ADT count used predict receptor expression within receiver cells. Note setting altExp_name = \"RNA\" enable users predict ligand-receptor interaction RNA expression . First, load database known ligand-receptor interactions query data. key challenge analyzing ligand–receptor interactions difference scaling distribution. Comparing unequal distributions can potentially introduce bias, especially ligand–receptor predictions means compared. address , first scaled feature range 0–1 min–max normalization transformed protein expression force low-expression values zero. ligand–receptor interaction pair originating cluster expressing ligand another cluster expressing receptor, permutation test performed mean average RNA expression ligand cluster mean protein expression receptor cluster. ligand–receptor pairs P-value lower 0.05 defined significant pairs. Alternative visualisation 1: visualise ligand-receptor predictions, can plot heatmap p-values indicating significant ligand-receptor pairs cluster groups.  Alternative visualisation 2: , plot network graph cluster groups, weight lines indicate number LR-pairs.  Alternative visualisation 3: Similarly, can visualise counts LR-pairs heatmap.","code":"# load the database of known ligand-receptor interactions from cellPhoneDB data(\"lr_pair_subset\", package = \"CiteFuse\") head(lr_pair_subset) #>      [,1]          [,2]    #> [1,] \"hg19_IL17RA\" \"CD45\"  #> [2,] \"hg19_FAS\"    \"CD11b\" #> [3,] \"hg19_GZMK\"   \"CD62L\" #> [4,] \"hg19_CD40LG\" \"CD11b\" #> [5,] \"hg19_FLT3LG\" \"CD62L\" #> [6,] \"hg19_GZMA\"   \"CD19\" sce_citeseq <- normaliseExprs(sce = sce_citeseq,                                altExp_name = \"ADT\",                                transform = \"zi_minMax\")  sce_citeseq <- normaliseExprs(sce = sce_citeseq,                                altExp_name = \"none\",                                exprs_value = \"logcounts\",                               transform = \"minMax\") sce_citeseq <- ligandReceptorTest(sce = sce_citeseq,                                   ligandReceptor_list = lr_pair_subset,                                   cluster = sce_citeseq$SNF_W_louvain,                                   RNA_exprs_value = \"minMax\",                                   use_alt_exp = TRUE,                                   altExp_name = \"ADT\",                                   altExp_exprs_value = \"zi_minMax\",                                   num_permute = 1000)  #> 100 ......200 ......300 ......400 ......500 ......600 ......700 ......800 ......900 ......1000 ...... visLigandReceptor(sce_citeseq,                    type = \"pval_heatmap\",                   receptor_type = \"ADT\") set.seed(2024) visLigandReceptor(sce_citeseq,                    type = \"group_network\",                   receptor_type = \"ADT\") visLigandReceptor(sce_citeseq,                    type = \"group_heatmap\",                   receptor_type = \"ADT\")"},{"path":"https://carissaynchen.github.io/SCMultiome-CNRS-workshop-R/articles/citefuse.html","id":"optional-evaluating-the-importance-of-adt-markers-in-clustering","dir":"Articles","previous_headings":"","what":"[Optional] Evaluating the importance of ADT markers in clustering","title":"Analysis of CITE-seq data with CiteFuse","text":"important evaluation CITE-seq data analysis assess quality ADT evaluate contribution ADTs towards clustering outcome. CiteFuse calculates relative importance ADT towards clustering outcome using random forest model. higher score ADT, greater importance towards final clustering outcome. importance scores can visualised boxplot heatmap. evaluation ADT importance show unsurprisingly CD4 CD8 top two discriminating proteins PBMCs.   test whether obtain similar clustering results using subset important markers, can try integration clustering ADTs score greater 5. see well integration performed subset ADT markers, can calculate concordance labels (ie. adjusted rand index, ARI). Interpretation: compare two clustering outcomes, find ARI approximately 0.85, value 1 denotes complete concordance. high ARI value suggests top markers primary contributors biological signals data, significantly influencing integration clustering patterns. Discussion: concordance set even higher threshold important ADT markers?","code":"set.seed(2024) sce_citeseq <- importanceADT(sce_citeseq,                               group = sce_citeseq$SNF_W_louvain,                              subsample = TRUE) visImportance(sce_citeseq, plot = \"boxplot\") visImportance(sce_citeseq, plot = \"heatmap\") # view the top 20 markers by decreasing importance sort(metadata(sce_citeseq)[[\"importanceADT\"]], decreasing = TRUE)[1:20] #>              CD27               CD8               CD4               CD5  #>         40.880877         37.389624         32.358307         12.257423  #>              CD28      PECAM (CD31)               CD7             CD11b  #>         12.054324         11.229291         10.941676         10.603099  #> IL7Ralpha (CD127)    MHCII (HLA-DR)              CD44               CD2  #>          9.908142          8.508850          8.507701          8.397517  #>      CD366 (tim3)         HLA-A,B,C             CD11c               CD3  #>          5.697106          5.688288          4.906899          4.769488  #>            CD45RA              CD69             CD62L              CD19  #>          4.279235          3.791519          3.602994          3.592245 subset_adt <- names(which(metadata(sce_citeseq)[[\"importanceADT\"]] > 5)) subset_adt #>  [1] \"CD11b\"             \"CD2\"               \"CD27\"              #>  [4] \"CD28\"              \"CD366 (tim3)\"      \"CD4\"               #>  [7] \"CD44\"              \"CD5\"               \"CD7\"               #> [10] \"CD8\"               \"HLA-A,B,C\"         \"IL7Ralpha (CD127)\" #> [13] \"MHCII (HLA-DR)\"    \"PECAM (CD31)\" sce_citeseq <- CiteFuse(sce_citeseq,                         ADT_subset = subset_adt,                         metadata_names = c(\"W_SNF_adtSubset1\",                                            \"W_ADT_adtSubset1\",                                            \"W_RNA\")) #> Calculating affinity matrix  #> Performing SNF  set.seed(2024) SNF_W_clust_adtSubset1 <- spectralClustering(metadata(sce_citeseq)[[\"W_SNF_adtSubset1\"]], K = 5) #> Computing Spectral Clustering sce_citeseq$SNF_W_clust_adtSubset1 <- as.factor(SNF_W_clust_adtSubset1$labels) mclust::adjustedRandIndex(sce_citeseq$SNF_W_clust_adtSubset1, sce_citeseq$SNF_W_clust) #> [1] 0.8499764"},{"path":"https://carissaynchen.github.io/SCMultiome-CNRS-workshop-R/articles/citefuse.html","id":"optional-performing-multi-sample-analysis-with-citefuse","dir":"Articles","previous_headings":"","what":"[Optional] Performing multi-sample analysis with CiteFuse","title":"Analysis of CITE-seq data with CiteFuse","text":"Lastly, jointly analyse current PBMC CITE-seq data, taken healthy human donors, another subset CITE-seq data patients cutaneous T-cell lymphoma (CTCL), Mimitou et al. (2019). data sce_ctcl_subset provided CiteFuse package already contains clustering information. visualise compare gene protein expression data, can use visualiseExprsList function. , visualise gene expression subset genes across two conditions individually identified cluster. Questions: visualise ADT expression?  can perform differential expression analysis RNA expression level across two clusters high CD19 expression ADT. Can gather anything biologically meaningful clusters looking top DE genes?","code":"data(\"sce_ctcl_subset\", package = \"CiteFuse\") visualiseExprsList(sce_list = list(control = sce_citeseq, ctcl = sce_ctcl_subset),                    plot = \"boxplot\",                    altExp_name = \"none\",                    exprs_value = \"logcounts\",                    feature_subset = c(\"hg19_S100A10\", \"hg19_CD8A\"),                    group_by = c(\"SNF_W_louvain\", \"SNF_W_louvain\")) # fill in code to visualise the ADT expression of CD19 and CD8 across the conditions de_res <- DEgenesCross(sce_list = list(control = sce_citeseq, ctcl = sce_ctcl_subset),                        colData_name = c(\"SNF_W_louvain\", \"SNF_W_louvain\"),                        group_to_test = c(\"2\", \"6\"))  de_res_filter <- selectDEgenes(de_res = de_res) de_res_filter #> $control #>             stats.W         pval     p.adjust meanExprs.1 meanExprs.2 #> hg19_GNLY      28.0 6.646869e-23 6.646869e-23  0.07220401    4.591530 #> hg19_CST7     149.5 4.403301e-21 4.403301e-21  0.22512314    2.640981 #> hg19_NKG7     165.0 8.951222e-21 8.951222e-21  0.51066894    3.815105 #> hg19_GZMH     301.0 1.984392e-19 1.984392e-19  0.00000000    1.972667 #> hg19_GZMB     474.0 3.856340e-17 3.856340e-17  0.11667246    2.017016 #> hg19_CCL5     474.0 1.010639e-16 1.010639e-16  1.04348029    3.772472 #> hg19_FGFBP2   548.0 1.623043e-16 1.623043e-16  0.03101677    1.666924 #> hg19_KLRD1    574.5 4.662465e-16 4.662465e-16  0.09327555    1.568567 #> hg19_EFHD2    794.0 5.121771e-14 5.121771e-14  0.02064028    1.212213 #> hg19_PRF1     801.5 9.024284e-14 9.024284e-14  0.06473009    1.467354 #>              meanPct.1 meanPct.2 meanDiff   pctDiff        name   group #> hg19_GNLY   0.02325581 0.9927007 4.519326 0.9694449   hg19_GNLY control #> hg19_CST7   0.13953488 0.9927007 2.415857 0.8531658   hg19_CST7 control #> hg19_NKG7   0.30232558 1.0000000 3.304436 0.6976744   hg19_NKG7 control #> hg19_GZMH   0.00000000 0.8978102 1.972667 0.8978102   hg19_GZMH control #> hg19_GZMB   0.06976744 0.8832117 1.900344 0.8134442   hg19_GZMB control #> hg19_CCL5   0.37209302 1.0000000 2.728992 0.6279070   hg19_CCL5 control #> hg19_FGFBP2 0.02325581 0.8248175 1.635907 0.8015617 hg19_FGFBP2 control #> hg19_KLRD1  0.09302326 0.8321168 1.475292 0.7390935  hg19_KLRD1 control #> hg19_EFHD2  0.02325581 0.7372263 1.191573 0.7139705  hg19_EFHD2 control #> hg19_PRF1   0.04651163 0.7591241 1.402624 0.7126125   hg19_PRF1 control #>  #> $ctcl #>               stats.W         pval     p.adjust meanExprs.1 meanExprs.2 #> hg19_LTB        368.0 6.626368e-28 6.626368e-28   0.1049424    1.978730 #> hg19_RPS26        0.0 4.957273e-23 4.957273e-23   1.6292756    5.072471 #> hg19_IL7R       747.0 5.147332e-21 5.147332e-21   0.1597474    1.651591 #> hg19_SELL      1006.0 3.198651e-20 3.198651e-20   0.0659935    1.152572 #> hg19_LEPROTL1   699.0 1.893136e-18 1.893136e-18   0.2381900    1.300745 #> hg19_EEF1B2     512.5 3.188785e-16 3.188785e-16   1.7119640    3.043623 #> hg19_HBB       1712.5 1.982149e-15 1.982149e-15   0.0000000    0.431026 #> hg19_NOSIP     1034.0 2.135217e-14 2.135217e-14   0.2014222    1.157235 #> hg19_FOS       1278.5 1.229947e-13 1.229947e-13   0.1492607    1.125337 #> hg19_NPM1       927.0 1.013945e-11 1.013945e-11   1.1724979    2.202268 #>                meanPct.1 meanPct.2  meanDiff   pctDiff          name group #> hg19_LTB      0.08029197 0.9069767 1.8737878 0.8266848      hg19_LTB  ctcl #> hg19_RPS26    0.89051095 1.0000000 3.4431949 0.1094891    hg19_RPS26  ctcl #> hg19_IL7R     0.10218978 0.8139535 1.4918432 0.7117637     hg19_IL7R  ctcl #> hg19_SELL     0.05109489 0.6976744 1.0865780 0.6465795     hg19_SELL  ctcl #> hg19_LEPROTL1 0.18978102 0.9069767 1.0625555 0.7171957 hg19_LEPROTL1  ctcl #> hg19_EEF1B2   0.86131387 0.9767442 1.3316593 0.1154303   hg19_EEF1B2  ctcl #> hg19_HBB      0.00000000 0.4186047 0.4310260 0.4186047      hg19_HBB  ctcl #> hg19_NOSIP    0.19708029 0.7674419 0.9558133 0.5703616    hg19_NOSIP  ctcl #> hg19_FOS      0.11678832 0.6511628 0.9760767 0.5343745      hg19_FOS  ctcl #> hg19_NPM1     0.72992701 0.9534884 1.0297701 0.2235614     hg19_NPM1  ctcl"},{"path":[]},{"path":"https://carissaynchen.github.io/SCMultiome-CNRS-workshop-R/articles/introduction_to_single-cell.html","id":"description","dir":"Articles","previous_headings":"Overview","what":"Description","title":"Introduction to Single-cell Pre-processing","text":"Single-cell RNA-sequencing allowed us dissect cellular heterogeneity finer resolution previously possible bulk RNA-sequencing. However, increase dimensionality comes unique challenges data processing analysis. section workshop, introduce basic pipeline check quality single-cell RNA-seq processed data perform necessary filtering remove low-quality cells. learning goals workshop understand implications filtering learn detect low-quality cells.  Preparation assumed knowledge Knowledge R syntax Familiarity Single-cell data analysis guide Familiarity SingleCellExperiment class  Learning objectives Carry typical single-cell processing QC workflow generate appropriate QC graphics","code":""},{"path":"https://carissaynchen.github.io/SCMultiome-CNRS-workshop-R/articles/introduction_to_single-cell.html","id":"schedule","dir":"Articles","previous_headings":"Overview","what":"Schedule","title":"Introduction to Single-cell Pre-processing","text":"Structure section:","code":""},{"path":"https://carissaynchen.github.io/SCMultiome-CNRS-workshop-R/articles/introduction_to_single-cell.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Introduction to Single-cell Pre-processing","text":"scRNA-seq data often plagued various sources noise technical artifacts, low-quality cells (eg. cells high rates cell death result single-cell dissociation), doublets, ambient RNA contamination. Adequately filtering data retain good quality cells, minimising technical artifacts crucial ensure accuracy reliability downstream analyses. Without proper filtering, results can skewed spurious signals, leading inaccurate biological interpretations conclusions. Typical procedures scRNA-seq filtering include removal cells low excessively high library sizes, cells high proportion mitochondrial gene expression (indicative high cell death) removal doublet cells (ie. two cells encapsulated one droplet, confounding considered ‘real cells’). steps help retain high-quality data accurately reflects true biological state sampled cells, thereby enabling robust meaningful insights scRNA-seq experiment. workshop, use mouse scRNA-seq data profiling hippocampus Hochgerner et al. (2018). original data can accessed GEO accession number GSE104323. original data contains 8 timepoints E16.5 postnatal 132 days, 24 unique cell types. access count matrices directly running CellRanger, purposes demonstration, assume dataset raw, un-processed count matrix, age separate sample.","code":""},{"path":"https://carissaynchen.github.io/SCMultiome-CNRS-workshop-R/articles/introduction_to_single-cell.html","id":"loading-libraries-and-the-data","dir":"Articles","previous_headings":"","what":"Loading libraries and the data","title":"Introduction to Single-cell Pre-processing","text":"First, let us load common packages single-cell processing. provide original data downloaded GSE104323 SingleCellExperiment class object. contains 24,185 cells 27,932 genes. typical functions interact SCE object.","code":"library(SingleCellExperiment) library(scater) library(ggthemes) library(scran) library(ggpubr) library(ggplot2) library(reshape2) library(patchwork) library(Seurat) library(parallel) library(BiocParallel) library(scDblFinder) library(DropletUtils) theme_set(theme_bw()) # code to load data  load(file=\"../data/hippocampus_all_ages.rda\") sce <- hippocampus_all_ages rm(hippocampus_all_ages) dim(sce) #> [1] 27932 24185 # colData(sce) # view column metadata # rowData(sce) # view row metadata # counts(sce) # extract counts matrix, warning - very large # rownames(sce) # extract rownames and column names as usual"},{"path":[]},{"path":"https://carissaynchen.github.io/SCMultiome-CNRS-workshop-R/articles/introduction_to_single-cell.html","id":"examining-sequencing-depth","dir":"Articles","previous_headings":"Initial inspection of the data","what":"Examining sequencing depth","title":"Introduction to Single-cell Pre-processing","text":"Assuming sequencing samples separated age, can first look reads obtained per library aggregating total cell counts age.  Interpretation: bar plot, see age different, particularly P120. Given sequencing run separate batches, ideally expect total reads approximately similar. Therefore, stage, can potentially flag low quality cells samples low total reads.","code":"reads <- colSums2(as.matrix(counts(sce))) reads <- sapply(split(1:length(reads), sce$age), function(x) sum(x)) reads <- reshape2::melt(reads) reads$sample <- rownames(reads) reads$sample <- factor(reads$sample, levels=c(\"E16.5\", \"P0\", \"P5\", \"P18\", \"P19\", \"P23\", \"P120\", \"P132\"))  ggplot(reads, aes(y=value, x=sample, fill=sample)) +    geom_col()"},{"path":"https://carissaynchen.github.io/SCMultiome-CNRS-workshop-R/articles/introduction_to_single-cell.html","id":"generating-qc-metrics-using-scater","dir":"Articles","previous_headings":"Initial inspection of the data","what":"Generating QC metrics using scater","title":"Introduction to Single-cell Pre-processing","text":"Next, use addPerCellQC function scater package calculate per-cell QC metrics count matrix. gives us sum counts (‘sum’), number detected features (‘detected’) also calculate metrics mitochondrial genes, common method measure cell death. measure sparsity gene expression cell calculating percentage zero counts per cell. visualise per-cell QC metrics using boxplot visualisation. Discussion: can infer quality samples boxplots? choose appropriate filtering thresholds? separate filtering thresholds applied sample?","code":"subset <- list(mito = grep(\"^MT-\", rownames(sce))) sce <- scater::addPerCellQC(sce, assay.type = \"counts\", subsets=subset, threshold=0) sce$pZero <- colSums2(as.matrix(counts(sce)) == 0)/nrow(sce) colnames(colData(sce))[13:18] <- c(\"nUMI\", \"nGenes\", \"nMito\", \"mitoGenes_detected\", \"pMito\", \"total\")  head(colData(sce)) #> DataFrame with 6 rows and 19 columns #>                                   sample_name   source_name     organism #>                                   <character>   <character>  <character> #> 10X79_1_TCTACCATGCCTAA 10X79_1_TCTACCATGCCT.. dentate gyrus Mus musculus #> 10X79_2_GTACTAGTGAACAT 10X79_2_GTACTAGTGAAC.. dentate gyrus Mus musculus #> 10X79_2_AATCAGTACCTACA 10X79_2_AATCAGTACCTA.. dentate gyrus Mus musculus #> 10X79_1_CGGGTTCTTGAGGT 10X79_1_CGGGTTCTTGAG.. dentate gyrus Mus musculus #> 10X79_1_GTGGAAGGCGTACA 10X79_1_GTGGAAGGCGTA.. dentate gyrus Mus musculus #> 10X79_1_GTCCGCAAGCCATT 10X79_1_GTCCGCAAGCCA.. dentate gyrus Mus musculus #>                             strain         age sex_of_pooled_animals #>                        <character> <character>           <character> #> 10X79_1_TCTACCATGCCTAA   hGFAP-GFP        P120        2males+1female #> 10X79_2_GTACTAGTGAACAT     C57Bl/6         P19                female #> 10X79_2_AATCAGTACCTACA     C57Bl/6         P19                female #> 10X79_1_CGGGTTCTTGAGGT   hGFAP-GFP        P120        2males+1female #> 10X79_1_GTGGAAGGCGTACA   hGFAP-GFP        P120        2males+1female #> 10X79_1_GTCCGCAAGCCATT   hGFAP-GFP        P120        2males+1female #>                        cell_cluster    molecule srr_run_accession #>                         <character> <character>       <character> #> 10X79_1_TCTACCATGCCTAA          RGL   total RNA        SRR6090459 #> 10X79_2_GTACTAGTGAACAT          RGL   total RNA        SRR6099081 #> 10X79_2_AATCAGTACCTACA          RGL   total RNA        SRR6099074 #> 10X79_1_CGGGTTCTTGAGGT          RGL   total RNA        SRR6090410 #> 10X79_1_GTGGAAGGCGTACA          RGL   total RNA        SRR6090448 #> 10X79_1_GTCCGCAAGCCATT          RGL   total RNA        SRR6090444 #>                        raw_file_original_file_name   umi_cellular_barcode #>                                        <character>            <character> #> 10X79_1_TCTACCATGCCTAA      10X79_1_TCTACCATGCCT.. TATGTCCCAG_TCTACCATG.. #> 10X79_2_GTACTAGTGAACAT      10X79_2_GTACTAGTGAAC.. CAGCTATTGG_GTACTAGTG.. #> 10X79_2_AATCAGTACCTACA      10X79_2_AATCAGTACCTA.. TTTAGCCTAT_AATCAGTAC.. #> 10X79_1_CGGGTTCTTGAGGT      10X79_1_CGGGTTCTTGAG.. CGTGAAGCGT_CGGGTTCTT.. #> 10X79_1_GTGGAAGGCGTACA      10X79_1_GTGGAAGGCGTA.. GGAGCCCGAC_GTGGAAGGC.. #> 10X79_1_GTCCGCAAGCCATT      10X79_1_GTCCGCAAGCCA.. ACAACCAGTC_GTCCGCAAG.. #>                                     cell_name      nUMI    nGenes     nMito #>                                   <character> <numeric> <numeric> <numeric> #> 10X79_1_TCTACCATGCCTAA 10X79_1_TCTACCATGCCTAA      2287      1201       129 #> 10X79_2_GTACTAGTGAACAT 10X79_2_GTACTAGTGAACAT      1847      1128       232 #> 10X79_2_AATCAGTACCTACA 10X79_2_AATCAGTACCTACA      2216      1202       296 #> 10X79_1_CGGGTTCTTGAGGT 10X79_1_CGGGTTCTTGAGGT      1455       999        76 #> 10X79_1_GTGGAAGGCGTACA 10X79_1_GTGGAAGGCGTACA      1553       943        77 #> 10X79_1_GTCCGCAAGCCATT 10X79_1_GTCCGCAAGCCATT      2568      1534       147 #>                        mitoGenes_detected     pMito     total     pZero #>                                 <numeric> <numeric> <numeric> <numeric> #> 10X79_1_TCTACCATGCCTAA                  9   5.64058      2287  0.957003 #> 10X79_2_GTACTAGTGAACAT                 10  12.56091      1847  0.959616 #> 10X79_2_AATCAGTACCTACA                 11  13.35740      2216  0.956967 #> 10X79_1_CGGGTTCTTGAGGT                  9   5.22337      1455  0.964235 #> 10X79_1_GTGGAAGGCGTACA                  9   4.95815      1553  0.966239 #> 10X79_1_GTCCGCAAGCCATT                 11   5.72430      2568  0.945081 metrics <- c(\"nUMI\", \"nGenes\", \"pMito\", \"pZero\", \"age\") qc_plot <- colData(sce)[ , metrics]  gg_list = list() for (i in 1:ncol(qc_plot)) {      df <- data.frame(sample = qc_plot$age,                    metric = qc_plot[, i])      metric_name <- colnames(qc_plot)[i]      gg_list[[i]] <- ggplot(df, aes(x = reorder(sample, metric, median), y=metric, fill=sample)) +     geom_boxplot() +     ggtitle(metric_name) +     theme(axis.title.x = element_blank()) }  patchwork::wrap_plots(gg_list[1:4], ncol=2, nrow=2, guides=\"collect\")"},{"path":"https://carissaynchen.github.io/SCMultiome-CNRS-workshop-R/articles/introduction_to_single-cell.html","id":"performing-cell-filtering","dir":"Articles","previous_headings":"","what":"Performing cell filtering","title":"Introduction to Single-cell Pre-processing","text":"Now visualised distribution QC metrics using boxplot, becomes clearer thresholds apply remove outlier cells. Generally, try remove cells low UMI counts sparse cells high percentage zero counts usually indicate cells insufficient sequencing depth. also remove cells extremely high UMI counts may indicate presence doublets. Lastly, usually set threshold according mitochondrial gene expression remove cells high rates cell death occurring. important keep mind cut-offs dataset-dependent cases, may want set lower stringent thresholds avoid removing rare cell populations capture cell types may specific characteristics. study Orsorio et al. performed systematic evaluation mitochondrial proportion human mice tissues serve guide decide appropriate mitochondrial threshold depending data. step, visualise distribution QC metrics performing cell filtering.  can also visualise many cells lost/remaining applying filtering thresholds. Based visualisations, filtering criteria think impact number cells retained?","code":"metrics <- c(\"nUMI\", \"nGenes\", \"pMito\", \"pZero\", \"age\") qc_plot <- colData(sce)[ , metrics]  idx = qc_plot$nUMI < 20000 & qc_plot$pMito < 10 & qc_plot$pZero < 0.98 qc_plot = qc_plot[idx, ]  filt_gg = lapply(1:ncol(qc_plot), function(x) {      df <- data.frame(sample = qc_plot$age,                    metric = qc_plot[, x])       metric_name <- colnames(qc_plot)[x]         g <- ggplot(df, aes(x = reorder(sample, metric, median), y=metric, fill=sample)) +     geom_boxplot() +     ggtitle(metric_name) +     theme(axis.title.x = element_blank())  })  patchwork::wrap_plots(filt_gg[1:4], ncol=2, nrow=2, guides=\"collect\") metrics <- c(\"nUMI\", \"nGenes\", \"pMito\", \"pZero\", \"age\") qc_plot <- colData(sce)[ , metrics]  idx <- qc_plot$nUMI < 20000 & qc_plot$pMito < 10 & qc_plot$pZero < 0.98 qc_plot$QC_cells <- idx qc_plot <- as.data.frame(qc_plot)  ggplot(qc_plot, aes(x=age, fill = QC_cells)) +   geom_bar(position=\"fill\")"},{"path":"https://carissaynchen.github.io/SCMultiome-CNRS-workshop-R/articles/introduction_to_single-cell.html","id":"performing-doublet-detection-using-scdblfinder","dir":"Articles","previous_headings":"","what":"Performing doublet detection using scDblFinder","title":"Introduction to Single-cell Pre-processing","text":"Single-cell RNA-seq experimental protocols require cell suspension distributed across single droplets (droplet microfluidics) single wells (well-based) intention capturing one cell per reaction volume (ie. singlet). , mRNA molecules labeled unique molecular code (UMI barcode). However, distribution step, one droplet well may capture one cell, creating ‘doublet’ cell sequenced single cell. doublet rate (.e., proportion doublets) scRNA-seq experiment depends throughput protocol. two major classes doublets: homotypic doublets, formed transcriptionally similar cells; heterotypic doublets, formed cells distinct types, lineages, states. Hence, doublet detection removal important step pre-processing can bias interpretation downstream analyses differential gene expression analysis, cell clustering trajectory analysis. , use scDblFinder shown competitive top-performing methods according excellent benchmark Xi et al.. running scDblFinder, first plot bar plot visualise many doublets dataset. , can additionally confirm indeed doublets visualisation distribution UMI counts, number genes proportion zero expression compared singlets. Discussion: notice differences distribution singlets doublets? expected ?   Interpretation: boxplots, see doublet population generally higher total UMI count, number genes expressed lower proportion zero counts. line expectations, predicted combined transcriptomic expression two cells instead single cell.","code":"sce <- scDblFinder(sce, samples=\"age\", clusters=TRUE, BPPARAM=MulticoreParam(3)) qc_plot <- data.frame(sample = sce$age, doublet = sce$scDblFinder.class)  ggplot(qc_plot, aes(x=sample,fill = doublet)) +   geom_bar(position=\"dodge\") metrics <- c(\"nUMI\", \"nGenes\", \"pMito\", \"pZero\", \"age\", \"scDblFinder.class\") qc_plot <- colData(sce)[ , metrics]  idx = qc_plot$nUMI < 20000 & qc_plot$pMito < 10 & qc_plot$pZero < 0.98 qc_plot$QC_cells <- idx  gg_list <- list() for (i in 1:ncol(qc_plot)) {      df <- data.frame(metric = qc_plot[, i],                    sample = qc_plot[, \"age\"],                    doublet_class = qc_plot[, \"scDblFinder.class\"],                    QC_cells = qc_plot[, \"QC_cells\"])   df <- df[df$QC_cells == TRUE, ]      metric_name <- colnames(qc_plot)[i]   gg_list[[i]] <- ggplot(df, aes(x = reorder(sample, metric, median), y=metric, fill=sample)) +      geom_boxplot() +     facet_wrap(~doublet_class, ncol = 2) +      ggtitle(metric_name) +     theme(axis.text.x = element_text(angle=45, vjust=1, hjust=1)) }  patchwork::wrap_plots(gg_list[c(1,2,4)], ncol=2, nrow=2, guides=\"collect\")"},{"path":"https://carissaynchen.github.io/SCMultiome-CNRS-workshop-R/articles/introduction_to_single-cell.html","id":"save-the-processed-data","dir":"Articles","previous_headings":"","what":"Save the processed data","title":"Introduction to Single-cell Pre-processing","text":"","code":"idx = sce$nUMI < 20000 & sce$pMito < 10 & sce$pZero < 0.98 & sce$scDblFinder.class == \"singlet\" sce <- sce[, idx]  # save(sce, file=\"data/hippocampus_processed.rda\")"},{"path":"https://carissaynchen.github.io/SCMultiome-CNRS-workshop-R/articles/introduction_to_single-cell.html","id":"extension-filtering-empty-droplets-using-dropletutils","dir":"Articles","previous_headings":"","what":"Extension – filtering empty droplets using DropletUtils","title":"Introduction to Single-cell Pre-processing","text":"Empty droplets often contain RNA ambient solution, resulting non-zero counts debarcoding. Thus, remove experimental artifacts, want distinguish empty droplets real cells. emptyDrops function testing barcode’s expression profile significant deviation ambient profile. , working raw CellRanger output, simulate count matrix empty droplets demonstrate utility step. Note, step typically run raw barcode matrix CellRanger, empty droplets removed default. perfectly fine use filtered barcode matrix, depending situation, may desirable start unfiltered matrix preserve cells. compute statistics using barcodeRanks function, create plot shown . plot shows log-total count log-rank barcode, highest ranked barcodes lowest total UMI counts. also shows inflection knee points curve, corresponding division total count distribution, predicting difference empty droplets cell-containing droplets.  Droplets significant deviations ambient profile detected specified FDR threshold, e.g., FDR 1%. can considered cell-containing droplets, frequency false positives (.e., empty droplets) specified FDR. Furthermore, droplets large counts automatically retained setting p-values zero. avoids discarding droplets containing cells similar ambient profile. Lastly, can plot diagnostic plot total UMI counts negative log-probability. Droplets detected real cells large negative log-probabilities large total counts.","code":"library(DropletUtils) set.seed(0) my.counts <- DropletUtils:::simCounts() br.out <- barcodeRanks(my.counts)  # Making a plot. plot(br.out$rank, br.out$total, log=\"xy\", xlab=\"Rank\", ylab=\"Total\") o <- order(br.out$rank) lines(br.out$rank[o], br.out$fitted[o], col=\"red\")  abline(h=metadata(br.out)$knee, col=\"dodgerblue\", lty=2) abline(h=metadata(br.out)$inflection, col=\"forestgreen\", lty=2) legend(\"bottomleft\", lty=2, col=c(\"dodgerblue\", \"forestgreen\"),      legend=c(\"knee\", \"inflection\")) set.seed(100) e.out <- emptyDrops(my.counts) e.out #> DataFrame with 11100 rows and 5 columns #>           Total   LogProb    PValue   Limited        FDR #>       <integer> <numeric> <numeric> <logical>  <numeric> #> 1             2        NA        NA        NA         NA #> 2             9        NA        NA        NA         NA #> 3            20        NA        NA        NA         NA #> 4            20        NA        NA        NA         NA #> 5             1        NA        NA        NA         NA #> ...         ...       ...       ...       ...        ... #> 11096       215  -246.428 9.999e-05      TRUE 0.00013799 #> 11097       201  -250.234 9.999e-05      TRUE 0.00013799 #> 11098       247  -275.905 9.999e-05      TRUE 0.00013799 #> 11099       191  -228.763 9.999e-05      TRUE 0.00013799 #> 11100       198  -233.043 9.999e-05      TRUE 0.00013799  is.cell <- e.out$FDR <= 0.01 sum(is.cell, na.rm=TRUE) #> [1] 943 plot(e.out$Total, -e.out$LogProb, col=ifelse(is.cell, \"red\", \"black\"),     xlab=\"Total UMI count\", ylab=\"-Log Probability\")"},{"path":"https://carissaynchen.github.io/SCMultiome-CNRS-workshop-R/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Carissa Chen. Author, maintainer. Sharon Long. Author. Pengyi Yang. Author.","code":""},{"path":"https://carissaynchen.github.io/SCMultiome-CNRS-workshop-R/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Chen C, Long S, Yang P (2024). SCMultiomeCNRSR: SCMultiome Workshop CNRS. R package version 0.1.0, https://carissaynchen.github.io/SCMultiome-CNRS-workshop-R/, https://github.com/carissaynchen/SCMultiome-CNRS-workshop-R.","code":"@Manual{,   title = {SCMultiomeCNRSR: SCMultiome Workshop at CNRS},   author = {Carissa Chen and Sharon Long and Pengyi Yang},   year = {2024},   note = {R package version 0.1.0, https://carissaynchen.github.io/SCMultiome-CNRS-workshop-R/},   url = {https://github.com/carissaynchen/SCMultiome-CNRS-workshop-R}, }"},{"path":[]},{"path":"https://carissaynchen.github.io/SCMultiome-CNRS-workshop-R/reference/clusPat.html","id":null,"dir":"Reference","previous_headings":"","what":"output from running clusterExpressionPattern from TradeSeq — clusPat","title":"output from running clusterExpressionPattern from TradeSeq — clusPat","text":"Data generated clustering genes along pseudotime lineage.","code":""},{"path":"https://carissaynchen.github.io/SCMultiome-CNRS-workshop-R/reference/clusPat.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"output from running clusterExpressionPattern from TradeSeq — clusPat","text":"","code":"data(clusPat, package = \"SCMultiomeCNRSR\")"},{"path":"https://carissaynchen.github.io/SCMultiome-CNRS-workshop-R/reference/clusPat.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"output from running clusterExpressionPattern from TradeSeq — clusPat","text":"object class list length 2.","code":""},{"path":"https://carissaynchen.github.io/SCMultiome-CNRS-workshop-R/reference/cluster1.markers_RNA_snn_res.0.1.html","id":null,"dir":"Reference","previous_headings":"","what":"wilcox DE test results for clustering results — cluster1.markers_RNA_snn_res.0.1","title":"wilcox DE test results for clustering results — cluster1.markers_RNA_snn_res.0.1","text":"Data generated running FindMarkers Seurat cluster 1 performing louvain clustering. Output SeuratObject.","code":""},{"path":"https://carissaynchen.github.io/SCMultiome-CNRS-workshop-R/reference/cluster1.markers_RNA_snn_res.0.1.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"wilcox DE test results for clustering results — cluster1.markers_RNA_snn_res.0.1","text":"","code":"data(cluster1.markers_RNA_snn_res.0.1, package = \"SCMultiomeCNRSR\")"},{"path":"https://carissaynchen.github.io/SCMultiome-CNRS-workshop-R/reference/cluster1.markers_RNA_snn_res.0.1.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"wilcox DE test results for clustering results — cluster1.markers_RNA_snn_res.0.1","text":"object class data.frame 9914 rows 5 columns.","code":""},{"path":"https://carissaynchen.github.io/SCMultiome-CNRS-workshop-R/reference/hippocampus_all_ages.html","id":null,"dir":"Reference","previous_headings":"","what":"mouse dentate gyrus hippocampus unprocessed scRNA-seq dataset — hippocampus_all_ages","title":"mouse dentate gyrus hippocampus unprocessed scRNA-seq dataset — hippocampus_all_ages","text":"Data Hochgerner et al. (2018) contains raw counts matrix metadata #' SingleCellExperiment Object","code":""},{"path":"https://carissaynchen.github.io/SCMultiome-CNRS-workshop-R/reference/hippocampus_all_ages.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"mouse dentate gyrus hippocampus unprocessed scRNA-seq dataset — hippocampus_all_ages","text":"","code":"data(hippocampus_all_ages, package = \"SCMultiomeCNRSR\")"},{"path":"https://carissaynchen.github.io/SCMultiome-CNRS-workshop-R/reference/hippocampus_all_ages.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"mouse dentate gyrus hippocampus unprocessed scRNA-seq dataset — hippocampus_all_ages","text":"object class SingleCellExperiment 27932 rows 24185 columns.","code":""},{"path":"https://carissaynchen.github.io/SCMultiome-CNRS-workshop-R/reference/hippocampus_all_ages.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"mouse dentate gyrus hippocampus unprocessed scRNA-seq dataset — hippocampus_all_ages","text":"Gene Expression Omnibus accession code GSE104323.","code":""},{"path":"https://carissaynchen.github.io/SCMultiome-CNRS-workshop-R/reference/hippocampus_all_ages.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"mouse dentate gyrus hippocampus unprocessed scRNA-seq dataset — hippocampus_all_ages","text":"Hochgerner, H., Zeisel, ., Lönnerberg, P. et al. Conserved properties dentate gyrus neurogenesis across postnatal development revealed single-cell RNA sequencing. Nat Neurosci 21, 290–299 (2018). https://doi.org/10.1038/s41593-017-0056-2","code":""},{"path":"https://carissaynchen.github.io/SCMultiome-CNRS-workshop-R/reference/hippocampus_minimal.html","id":null,"dir":"Reference","previous_headings":"","what":"subset of mouse dentate gyrus hippocampus processed scRNA-seq dataset — hippocampus_minimal","title":"subset of mouse dentate gyrus hippocampus processed scRNA-seq dataset — hippocampus_minimal","text":"mouse dentate gyrus hippocampus processed scRNA-seq dataset subsetted cells P0 P5 stages showcasing cell types two lineages","code":""},{"path":"https://carissaynchen.github.io/SCMultiome-CNRS-workshop-R/reference/hippocampus_minimal.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"subset of mouse dentate gyrus hippocampus processed scRNA-seq dataset — hippocampus_minimal","text":"","code":"data(hippocampus_minimal, package = \"SCMultiomeCNRSR\")"},{"path":"https://carissaynchen.github.io/SCMultiome-CNRS-workshop-R/reference/hippocampus_minimal.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"subset of mouse dentate gyrus hippocampus processed scRNA-seq dataset — hippocampus_minimal","text":"object class SingleCellExperiment 27932 rows 5412 columns.","code":""},{"path":"https://carissaynchen.github.io/SCMultiome-CNRS-workshop-R/reference/hippocampus_processed.html","id":null,"dir":"Reference","previous_headings":"","what":"mouse dentate gyrus hippocampus processed scRNA-seq dataset — hippocampus_processed","title":"mouse dentate gyrus hippocampus processed scRNA-seq dataset — hippocampus_processed","text":"Data Hochgerner et al. (2018) contains raw counts matrix metadata #' SingleCellExperiment Object performing basic pre-processing","code":""},{"path":"https://carissaynchen.github.io/SCMultiome-CNRS-workshop-R/reference/hippocampus_processed.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"mouse dentate gyrus hippocampus processed scRNA-seq dataset — hippocampus_processed","text":"","code":"data(hippocampus_processed, package = \"SCMultiomeCNRSR\")"},{"path":"https://carissaynchen.github.io/SCMultiome-CNRS-workshop-R/reference/hippocampus_processed.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"mouse dentate gyrus hippocampus processed scRNA-seq dataset — hippocampus_processed","text":"object class SingleCellExperiment 27932 rows 18297 columns.","code":""},{"path":"https://carissaynchen.github.io/SCMultiome-CNRS-workshop-R/reference/scHOT_obj.html","id":null,"dir":"Reference","previous_headings":"","what":"scHOT output to identify differentially correlated gene pairs. — scHOT_obj","title":"scHOT output to identify differentially correlated gene pairs. — scHOT_obj","text":"Data generated running scHOT function identify gene pairs vary correlation across pseudotime.","code":""},{"path":"https://carissaynchen.github.io/SCMultiome-CNRS-workshop-R/reference/scHOT_obj.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"scHOT output to identify differentially correlated gene pairs. — scHOT_obj","text":"","code":"data(scHOT_obj, package = \"SCMultiomeCNRSR\")"},{"path":"https://carissaynchen.github.io/SCMultiome-CNRS-workshop-R/reference/scHOT_obj.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"scHOT output to identify differentially correlated gene pairs. — scHOT_obj","text":"object class scHOT 27932 rows 2672 columns.","code":""},{"path":"https://carissaynchen.github.io/SCMultiome-CNRS-workshop-R/reference/slingshot_umap.html","id":null,"dir":"Reference","previous_headings":"","what":"output from fitting the NB-GAM model in TradeSeq — slingshot_umap","title":"output from fitting the NB-GAM model in TradeSeq — slingshot_umap","text":"Data generated running fitGAM model gene expression changes function pseudotime. Output SlingShot Object.","code":""},{"path":"https://carissaynchen.github.io/SCMultiome-CNRS-workshop-R/reference/slingshot_umap.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"output from fitting the NB-GAM model in TradeSeq — slingshot_umap","text":"","code":"data(slingshot_umap, package = \"SCMultiomeCNRSR\")"},{"path":"https://carissaynchen.github.io/SCMultiome-CNRS-workshop-R/reference/slingshot_umap.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"output from fitting the NB-GAM model in TradeSeq — slingshot_umap","text":"object class SingleCellExperiment 27932 rows 5412 columns.","code":""}]
